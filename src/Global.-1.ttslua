--[[

  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2018  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

]]

redColor = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}

codeLocations =
{
  { x = -11.4, y = 1.03, z = 12.6 }, { x = -5.7, y = 1.03, z = 12.6 }, { x = 0, y = 1.03, z = 12.6 }, { x = 5.7, y = 1.03, z = 12.6 }, { x = 11.4, y = 1.03, z = 12.6 },
  { x = -11.4, y = 1.03, z = 8.75 }, { x = -5.7, y = 1.03, z = 8.75 }, { x = 0, y = 1.03, z = 8.75 }, { x = 5.7, y = 1.03, z = 8.75 }, { x = 11.4, y = 1.03, z = 8.75 },
  { x = -11.4, y = 1.03, z = 4.9  }, { x = -5.7, y = 1.03, z = 4.9  }, { x = 0, y = 1.03, z = 4.9  }, { x = 5.7, y = 1.03, z = 4.9  }, { x = 11.4, y = 1.03, z = 4.9  },
  { x = -11.4, y = 1.03, z = 1.05 }, { x = -5.7, y = 1.03, z = 1.05 }, { x = 0, y = 1.03, z = 1.05 }, { x = 5.7, y = 1.03, z = 1.05 }, { x = 11.4, y = 1.03, z = 1.05 },
  { x = -11.4, y = 1.03, z = -2.8 }, { x = -5.7, y = 1.03, z = -2.8 }, { x = 0, y = 1.03, z = -2.8 }, { x = 5.7, y = 1.03, z = -2.8 }, { x = 11.4, y = 1.03, z = -2.8 }
}

agentLocations =
{
  -- Assassain
  ['b97df2']={ 0.04, 2, -17.84 };
  -- Blue agents
  ['7fdaee']={ 12.34, 2, -13.97 }, ['99832c']={ 18.07, 2, -13.97 }, ['d9324a']={ 23.77, 2, -13.97 }, ['19b2d5']={ 29.47, 2, -13.97 },
  ['0f0ec0']={ 12.34, 2, -17.8  }, ['d9054c']={ 18.07, 2, -17.8  }, ['4de840']={ 23.77, 2, -17.8  }, ['05c73d']={ 29.47, 2, -17.8  };
  -- Red agents
  ['b48ed4']={ -29.32, 2, -13.97 }, ['6bb4d8']={ -23.62, 2, -13.97 }, ['9cbe84']={ -17.92, 2, -13.97 }, ['746660']={ -12.22, 2, -13.97 },
  ['4a2969']={ -29.32, 2, -17.8  }, ['e1754e']={ -23.62, 2, -17.8  }, ['b89ba7']={ -17.92, 2, -17.8  }, ['5c1be6']={ -12.22, 2, -17.8  };
  -- Civialians
  ['f6786b']={ -5.7, 2, -21.7 }, ['e44594']={ -5.7, 2, -17.84 }, ['1f53f2']={ -5.7, 2, -14 },
  ['f8f6a1']={ 0.04, 2, -21.7 },
  ['a05e4e']={ 5.74, 2, -21.7 }, ['1ebedd']={ 5.74, 2, -17.84 }, ['3d7b86']={ 5.74, 2, -14 };
  -- Double agents
  ['1e9282']={ 0.04, 2, -14 };
  ['3ef1ca']={ 0.04, 3, -14 };
}

agentColors =
{
  -- Assassain
  ['b97df2'] = 'black',

  -- Blue agents
  ['7fdaee'] = 'blue',
  ['99832c'] = 'blue',
  ['d9324a'] = 'blue',
  ['19b2d5'] = 'blue',
  ['0f0ec0'] = 'blue',
  ['d9054c'] = 'blue',
  ['4de840'] = 'blue',
  ['05c73d'] = 'blue',

  -- Red agents
  ['b48ed4'] = 'red',
  ['6bb4d8'] = 'red',
  ['9cbe84'] = 'red',
  ['746660'] = 'red',
  ['4a2969'] = 'red',
  ['e1754e'] = 'red',
  ['b89ba7'] = 'red',
  ['5c1be6'] = 'red',

  -- Civialians
  ['f6786b'] = 'white',
  ['e44594'] = 'white',
  ['1f53f2'] = 'white',
  ['f8f6a1'] = 'white',
  ['a05e4e'] = 'white',
  ['1ebedd'] = 'white',
  ['3d7b86'] = 'white',

  -- Double agents
  ['1e9282'] = 'blue',
  ['3ef1ca'] = 'red'
}

size =
{
  -- Small buttons
  small =
  {
    width     = 1800,
    height    = 1200,
    font_size = 340
  },

  -- Medium buttons
  medium =
  {
    width     = 3200,
    height    = 1200,
    font_size = 400
  }
}

function onload(saveState)

  -- Global variables --

  -- Global game mode
  gameStarted = false
  firstTurn = true
  -- Keeps track of whether or not a new game is in the process of starting
  newGameStarting = false
  -- Keeps track of whether or not we are currently shuffling players
  shufflingPlayers = false
  -- Timer warning variable
  timerWarning = -1
  -- 0 = RED; 1 = BLUE
  turnTracker = 1

  settings =
  {
    playerShuffle = false,

    afkDetection =
    {
      enabled   = true,
      threshold = 10
    },

    timer =
    {
      enabled     = true,
      initial     = 10,
      subsequent  = 5
    },

    codemasterQueue = true
  }

  -- Used for game analytics - ryan6578.com
  analytics =
  {
    -- Opt out of analytics?
    optOut = false, -- Opt out of analytics if you so wish
    g = "",
    h = "",
    d = ""
  }
  if not analytics.optOut then
    for i, player in ipairs(Player.getPlayers()) do
      if player.host then
        analytics.h = player.steam_id
        break
      end
    end
  end

  -- Illegal move tracking
  updateTimer = 0
  illegalMove = false

  -- Configuration panel settings
  codemasterQueue = {}
  afkTracker = {}

  -- Tracks the amount of guesses the current team has left
  guessesLeft = -1

  -- Keep track of team announcements
  announceTracker = {}

  -- Red clue tracker
  redClues = {}
  redCluesTracker = 0

  -- Blue clue tracker
  blueClues = {}
  blueCluesTracker = 0

  -- Tracks pickup locations of agents
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  -- Tracks correct answers
  correctTracker = {}

  -- Keeps track of the GUIDs of codes in play
  cardsInPlayArea = {}

  -- X, Z coordinates
  keymap = {
    ["-11.4,12.6"] = "", ["-5.7,12.6"] = "", ["0,12.6"] = "", ["5.7,12.6"] = "", ["11.4,12.6"] = "",
    ["-11.4,8.75"] = "", ["-5.7,8.75"] = "", ["0,8.75"] = "", ["5.7,8.75"] = "", ["11.4,8.75"] = "",
    ["-11.4,4.9"] = "", ["-5.7,4.9"] = "", ["0,4.9"] = "", ["5.7,4.9"] = "", ["11.4,4.9"] = "",
    ["-11.4,1.05"] = "", ["-5.7,1.05"] = "", ["0,1.05"] = "", ["5.7,1.05"] = "", ["11.4,1.05"] = "",
    ["-11.4,-2.8"] = "", ["-5.7,-2.8"] = "", ["0,-2.8"] = "", ["5.7,-2.8"] = "", ["11.4,-2.8"] = ""
  }

  -- lights toggles
  spaceBG = getObjectFromGUID("7b8161")
  spaceBG.interactable = false
  spaceParticles = getObjectFromGUID("8430cf")
  spaceParticles.interactable = false
  teamlights = 1
  ambientlights = 1
  ambient_bot = getObjectFromGUID("6fb111")
  ambient_bot.interactable = false
  ambient_top = getObjectFromGUID("05032c")
  ambient_top.interactable = false
  teams_red = getObjectFromGUID("a1b2cd")
  teams_red.interactable = false
  teams_blue = getObjectFromGUID("6072b1")
  teams_blue.interactable = false

  -- Control panel declarations
  gameCP = getObjectFromGUID("ec0882")
  gameCP.interactable = false
  settingsCP = getObjectFromGUID("0837df")
  settingsCP.interactable = false

  drawGameCP()
  drawSettingsCP()

  -- Codemaster Queue
  queuePanel = getObjectFromGUID("c67626")
  queuePanel.interactable = false
  local queueTextParam = {
    label="Codemaster Queue",
    click_function="nullFunction",
    function_owner=self,
    position={-6.75,0.2,0},
    rotation={0,-90,0},
    height=0,
    width=0,
    font_color={1,1,1},
    font_size=500
  }
  local joinButtonParam = {
    label="Join",
    click_function="joinQueue",
    function_owner=self,
    position={6.75,0.2,3.2},
    rotation={0,-90,0},
    height=500,
    width=1400,
    font_size=400
  }
  local joinStayButtonParam = {
    label="Stay",
    click_function="joinQueueStay",
    function_owner=self,
    position={6.75,0.2,0},
    rotation={0,-90,0},
    height=500,
    width=1400,
    font_size=400
  }
  local leaveButtonParam = {
    label="Leave",
    click_function="leaveQueue",
    function_owner=self,
    position={6.75,0.2,-3.2},
    rotation={0,-90,0},
    height=500,
    width=1400,
    font_size=400
  }

  queuePanel.createButton(queueTextParam)
  queuePanel.createButton(joinButtonParam)
  queuePanel.createButton(joinStayButtonParam)
  queuePanel.createButton(leaveButtonParam)


  deckVanilla = getObjectFromGUID("83b607")
  deckHanii = getObjectFromGUID("92bb6b")
  deckCHRY = getObjectFromGUID("41f57c")
  deckUndercover = getObjectFromGUID("ee8afd")
  deckSaydi = getObjectFromGUID("d75160")
  deckMayor = getObjectFromGUID("3a3e8c")
  deckVanilla.interactable = false
  deckHanii.interactable = false
  deckCHRY.interactable = false
  deckUndercover.interactable = false
  deckSaydi.interactable = false
  deckMayor.interactable = false

  decks = {
    -- Vanilla
    [1] = deckVanilla,

    -- Hanii
    [2] = deckHanii,

    -- CHRY
    [3] = deckCHRY,

    -- Undercover
    [4] = deckUndercover,

    -- Saydi's
    [5] = deckSaydi,

    -- Mayor's
    [6] = deckMayor
  }

  -- Until the clue announcements work
  --clueTablet = getObjectFromGUID("69b440")
  --clueTablet.interactable = false

  deckZone = getObjectFromGUID("33d9ff")

  deckDealer = getObjectFromGUID("27d226")

  -- Keymap zone
  keymapZone = getObjectFromGUID("773642")
  local zoneColor = keymapZone.getValue()
  if Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  zoneToClear = getObjectFromGUID("f71f4c")
  clueZone = getObjectFromGUID("f71f4c")

  buttonRed = getObjectFromGUID("f16a9a")
  buttonBlu = getObjectFromGUID("c91f34")
  buttonTeams = getObjectFromGUID("8a85e8")
  buttonTeams.interactable = false
  buttonTeams.setLock(true)

  -- Red team plaque position and rotation
  redPos = {-20.7, 0.91, 17.94}
  redRot = {0, 180, 0}

  -- Blue team plaque position and rotation
  bluePos = {20.7, 0.91, 17.94}
  blueRot = {0, 180, 180}

  clockTimer = getObjectFromGUID("0b1336")

  tileZone = getObjectFromGUID("06b292")

  buttonBlu.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- red clue encoder
  redToken = getObjectFromGUID("f3cdf2")
  redToken.interactable = false

  -- blue clue encoder
  blueToken = getObjectFromGUID("3f75b3")
  blueToken.interactable = false

  -- Blue encoding station
  blueEncoding = getObjectFromGUID("2ef93a")
  blueEncoding.setLock(true)
  drawEncodeInput(blueEncoding)
  -- Red encoding station
  redEncoding = getObjectFromGUID("7793cd")
  redEncoding.setLock(true)
  drawEncodeInput(redEncoding)

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    gameStarted = decodedSaveState.gameStarted
    settings = decodedSaveState.settings
    timerWarning = decodedSaveState.timerWarning
    turnTracker = decodedSaveState.turnTracker
    first_random = decodedSaveState.first_random

    updateTimer = decodedSaveState.updateTimer
    illegalMove = decodedSaveState.illegalMove

    for pos, guid in pairs(JSON.decode(decodedSaveState.correctTracker)) do
      local agent = getObjectFromGUID(guid)
      if getObjectFromGUID(guid).getLock() == true then
        correctTracker[pos] = guid
        agent.interactable = false
      end
    end

    for i, cardGuid in ipairs(JSON.decode(decodedSaveState.cardsInPlayArea)) do
      cardsInPlayArea[i] = getObjectFromGUID(cardGuid)
    end

    for pos, color in pairs(JSON.decode(decodedSaveState.keymap)) do
      keymap[pos] = color
    end
  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function onSave()
  local saveData = {}

  saveData.gameStarted = gameStarted
  saveData.settings = settings
  saveData.timerWarning = timerWarning
  saveData.turnTracker = turnTracker
  saveData.first_random = first_random

  saveData.updateTimer = updateTimer
  saveData.illegalMove = illegalMove

  saveData.correctTracker = JSON.encode(correctTracker)

  local endcodedCardsInPlayArea = {}
  for i, card in ipairs(cardsInPlayArea) do
    endcodedCardsInPlayArea[i] = card.guid
  end
  saveData.cardsInPlayArea = JSON.encode(endcodedCardsInPlayArea)

  saveData.keymap = JSON.encode(keymap)

  return JSON.encode(saveData)
end

function nullFunction()
  -- Nothing
end

function delayDrawEncodeInput(params)
  Timer.destroy(params.id)
  drawEncodeInput(params.obj)
end

function drawEncodeInput(object)
  -- Clear existing inputs
  object.clearInputs()

  -- Draw a new input
  local inputParams =
  {
    input_function  = "cluemasterEncode",
    function_owner  = self,
    tooltip         = "- Enter Clue Here -",
    label           = "- Enter Clue Here -",
    position        = {0, 1, 0},
    rotation        = {0, 180, 0},
    scale           = {0.1, 10, 1/2},
    alignment       = 3,
    width           = 4000,
    height          = 300,
    font_size       = 250,
    value           = ""
  }
  object.createInput(inputParams)
end

function drawGameCP()
  -- Clear all the existing buttons on the CP
  gameCP.clearButtons()

  -- Draw buttons
  makeButton(gameCP, "Vanilla\nCodenames", "resetVanilla", {x = -5.5, z = -3}, size.small)
  makeButton(gameCP, "Haniis\nCodenames", "resetHanii", {x = -5.5, z = 0}, size.small)
  makeButton(gameCP, "CHRYs\nCodenames", "resetCHRY", {x = -1.5, z = -3}, size.small)
  makeButton(gameCP, "Codenames:\nUndercover", "resetUndercover", {x = -1.5, z = 0}, size.small)
  makeButton(gameCP, "Saydi's\nCodenames", "resetSaydi", {x = -5.5, z = 3}, size.small)
  makeButton(gameCP, "Mayor's\nCodenames", "resetMayor", {x = -1.5, z = 3}, size.small)
  makeButton(gameCP, "New Game\n(Reset)", "newGame", {x = 4, z = -3}, size.medium)
end

function drawSettingsCP()
  -- Clear all the existing buttons on the CP
  settingsCP.clearButtons()

  -- Draw the buttons with updated values
  makeCheckbox(settingsCP, "Shuffle Players at Start", "toggleShuffle", {x = -6.5, z = -3.5}, 6, settings.playerShuffle, false)
  makeCheckbox(settingsCP, "Enable Codemaster Queue", "toggleQueue", {x = -6.5, z = -2.3}, 6.5, settings.codemasterQueue, false)
  makeCheckbox(settingsCP, "AFK Detection", "toggleAFK", {x = -6.5, z = -1.1}, 4.1, settings.afkDetection.enabled, false)
  makeCounter(settingsCP, settings.afkDetection.threshold, "minutes", "incAFK", "decAFK", {x = -5, z = 0.1}, 3, not settings.afkDetection.enabled)
  makeCheckbox(settingsCP, "Timer Enabled", "toggleTimer", {x = -6.5, z = 1.3}, 4.1, settings.timer.enabled, false)
  makeCounter(settingsCP, settings.timer.initial, "minutes (round 1)", "incInitTimer", "decInitTimer", {x = -5, z = 2.5}, 5.2, not settings.timer.enabled)
  makeCounter(settingsCP, settings.timer.subsequent, "minutes (round 2+)", "incSubTimer", "decSubTimer", {x = -5, z = 3.7}, 5.5, not settings.timer.enabled)
end

function makeButton(object, buttonLabel, callback, position, size)
  local attributes =
  {
    click_function  = callback,
    function_owner  = self,
    label           = buttonLabel,
    position        = {x = position.x, y = 0.2, z = position.z},
    rotation        = {0, 0, 0},
    width           = size.width,
    height          = size.height,
    font_size       = size.font_size
  }
  object.createButton(attributes)
end

function makeCheckbox(object, textLabel, callback, position, textOffset, checked, disabled)
  local check =
  {
    label           = (checked and "✔" or ""),
    click_function  = callback,
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = {0, 0, 0},
    height          = 500,
    width           = 500,
    font_size       = 400
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {(position.x + textOffset), 0.2, (position.z + 0.1)},
    rotation        = {0, 0, 0},
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 500
  }
  if disabled then
    check.color = {0.5, 0.5, 0.5}
    check.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(check)
  object.createButton(text)
end

function makeCounter(object, value, textLabel, incCB, decCB, position, textOffset, disabled)
  local num =
  {
    label           = tostring(value),
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = {0, 0, 0},
    height          = 500,
    width           = 500,
    font_size       = 400
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {(position.x + textOffset), 0.2, (position.z + 0.1)},
    rotation        = {0, 0, 0},
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 500
  }
  local decrement =
  {
    label           = "-",
    click_function  = decCB,
    function_owner  = self,
    position        = {(position.x - 0.8), 0.2, position.z},
    rotation        = {0, 0, 0},
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  local increment =
  {
    label           = "+",
    click_function  = incCB,
    function_owner  = self,
    position        = {(position.x + 0.8), 0.2, position.z},
    rotation        = {0, 0, 0},
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  if disabled then
    num.color = {0.5, 0.5, 0.5}
    num.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
    decrement.color = {0.5, 0.5, 0.5}
    decrement.font_color = {0.25, 0.25, 0.25}
    increment.color = {0.5, 0.5, 0.5}
    increment.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(num)
  object.createButton(text)
  object.createButton(decrement)
  object.createButton(increment)
end

function decInitTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.timer.enabled then
      if settings.timer.initial > 1 then
        settings.timer.initial = settings.timer.initial - 1
        drawSettingsCP()
      end
    end
  end
end

function incInitTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.timer.enabled then
      if settings.timer.initial < 20 then
        settings.timer.initial = settings.timer.initial + 1
        drawSettingsCP()
      end
    end
  end
end

function decSubTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.timer.enabled then
      if settings.timer.subsequent > 1 then
        settings.timer.subsequent = settings.timer.subsequent - 1
        drawSettingsCP()
      end
    end
  end
end

function incSubTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.timer.enabled then
      if settings.timer.subsequent < 20 then
        settings.timer.subsequent = settings.timer.subsequent + 1
        drawSettingsCP()
      end
    end
  end
end

function decAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold > 1 then
        settings.afkDetection.threshold = settings.afkDetection.threshold - 1
        drawSettingsCP()
      end
    end
  end
end

function incAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold < 60 then
        settings.afkDetection.threshold = settings.afkDetection.threshold + 1
        drawSettingsCP()
      end
    end
  end
end

function shufflePlayers(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    startLuaCoroutine(Global, "startShuffle")
  end
end

function findPlayerBySteamID(steam_id)
  for _, player in ipairs(Player.getPlayers()) do
    if player.steam_id == steam_id then
      return player
    end
  end
end

function findPlayerByColor(color)
  for _, player in ipairs(Player.getPlayers()) do
    if player.color == color then
      return player
    end
  end
end

function sleep(t)
  for i=1,t do
    coroutine.yield(0)
  end
end

function swapCodemasters()
local players = {}
  -- remove gray or black players from the codemasterQueue
  for _, player in ipairs(Player.getPlayers()) do
    if player.color == "Grey" or player.color == "Black" then
      for i, queuePlayer in ipairs(codemasterQueue) do
        if player.steam_id == queuePlayer.steam_id then
          table.remove(codemasterQueue,i)
        end
      end
    end
  end

  local seats = {
    "Blue",
    "Red"
  }
  local free = {}
  local swap = {}
  local reinsert = {}

  --Sort seats to prefer empty seats
  for i, seat in ipairs(seats) do
    if not Player[seat].seated then
      table.insert(free, seat)
    else
      table.insert(swap, seat)
    end
  end

  shufflingPlayers = true
  --run up to 2 times
  for i = 1,2 do
    --if the queue is empty, break
    if #codemasterQueue < 1 then break end
    --grab random seat from empty seats if available
    if #free > 0 then
      seat = table.remove(free,math.random(1,#free))
    else
      seat = table.remove(swap,math.random(1,#swap))
    end

    --get the first player in the queue
    local player = findPlayerBySteamID(codemasterQueue[1].steam_id)

    --if they are selected to stay, save them to reinsert later
    if codemasterQueue[1].stay then
      table.insert(reinsert,table.remove(codemasterQueue,1))
    else
      table.remove(codemasterQueue,1)
    end

    if not Player[seat].seated then
        --if the seat is empty, we only have to seat the player there
      player.changeColor(seat)
    elseif not (player.color == seat) then
      -- if the seat is occupied, get the player that is currently sitting there
      local oldPlayer = findPlayerByColor(seat)
      --get the color of queued player
      local oldColor = player.color
      --change the player in the seat to grey
      oldPlayer.changeColor("Grey")
      sleep(5)
      --move the queued player to the seat
      player.changeColor(seat)
      sleep(5)
      --move the old player to the queued players old seat
      oldPlayer.changeColor(oldColor)
    end
    sleep(5)
  end

  shufflingPlayers = false

  for _, player in ipairs(reinsert) do table.insert(codemasterQueue,player) end

  redrawQueue()

  -- Delay afterwards

  sleep(250)

  -- Continue game setup if in progress
  if newGameStarting then
    dealCards(cardsToDeal)
    reset_keymap()
  end

  return 1
end

function startShuffle()
  local seatedPlayers = Player.getPlayers()
  local players = {}
  local seats = {}
  local reinsert = {}
  for _, player in ipairs(seatedPlayers) do
    -- grab all players that aren't gray or black
    if player.color != "Grey" and player.color != "Black" then
      table.insert(players, player)
    else
      -- remove gray or black players from the codemasterQueue
      for i, queuePlayer in ipairs(codemasterQueue) do
        if player.steam_id == queuePlayer.steam_id then
          table.remove(codemasterQueue,i)
        end
      end
    end
  end
  if #players > 0 then

    shufflingPlayers = true

    local seatColors = {
      "Blue",
      "Red",
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local randSide = math.random(0,1)

    -- Remove the colors we don't need
    for i, seat in ipairs(seatColors) do
      if i <= #players then
        if #players % 2 != 0 and i == #players then
          table.insert(seats, seatColors[i + randSide])
        else
          table.insert(seats, seatColors[i])
        end
      else
        break
      end
    end

    -- Stand all player
    for _, player in ipairs(players) do
      player.changeColor("Grey")
      sleep(5)
    end

    -- Sit players back down
    for i, seat in ipairs(seats) do
      if settings.codemasterQueue and i <= 2 and #codemasterQueue > 0 then
        for index, player in ipairs(players) do
          if player.steam_id == codemasterQueue[1].steam_id then
            table.remove(players, index)
            if codemasterQueue[1].stay then
              table.insert(reinsert,table.remove(codemasterQueue,1))
            else
              table.remove(codemasterQueue,1)
            end
            player.changeColor(seat)
            break
          end
        end
      else
        local randPlayer = table.remove(players, math.random(1, #players))
        randPlayer.changeColor(seat)
      end
      sleep(5)
    end

    for _, player in ipairs(reinsert) do table.insert(codemasterQueue,player) end
    shufflingPlayers = false

    redrawQueue()

    -- Delay afterwards

    sleep(250)


    -- Continue game setup if in progress
    if newGameStarting then
      dealCards(cardsToDeal)
      reset_keymap()
    end
  else
    Player[color].broadcast("Not enough players to shuffle!", redColor)
  end

  return 1
end

function toggleShuffle(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.playerShuffle = not settings.playerShuffle
    drawSettingsCP()
  end
end


function toggleQueue(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.codemasterQueue = not settings.codemasterQueue
    if settings.codemasterQueue then
      -- Show the panel
      queuePanel.setRotation({0, 270, 0})
      queuePanel.setPosition({-8, 0.91, -32})
    else
      -- Hide the panel
      queuePanel.setPosition({-8, -0.5, -32})
      queuePanel.setRotation({0, 90, 180})
    end
    drawSettingsCP()
  end
end

function redrawQueue()
  -- get number of buttons, ignoring the original 4
  local nButtons = #queuePanel.getButtons() - 4
  -- removing buttons back to front so that indexes don't shift down while we are looping
  for i = nButtons+3,4,-1 do
    queuePanel.removeButton(i)
  end
  for i, player in ipairs(codemasterQueue) do
    local PlayerButtonParam = {
      label=player.steam_name,
      click_function="nullFunction",
      function_owner=self,
      position={-6.35 + (1.1*i),0.2,0},
      rotation={0,-90,0},
      height=500,
      width=4200,
      font_size=400
    }
    if player.stay then
      PlayerButtonParam.color = {0.8,1,0.8}
    end
    queuePanel.createButton(PlayerButtonParam)
  end

end


function joinQueue(o, color)
  if color == "Black" then
    Player[color].broadcast("Please switch colors before attempting to join the codemaster queue.", redColor)
    return
  end
  for _, player in ipairs(codemasterQueue) do
    if Player[color].steam_id == player.steam_id then
      if player.stay then
        player.stay = false
        redrawQueue()
      end
      return
    end
  end
  local playerInfo =
  {
    steam_id   = Player[color].steam_id,
    steam_name = Player[color].steam_name,
    stay       = false
  }
  table.insert(codemasterQueue,playerInfo)
  redrawQueue()
end

function joinQueueStay(o, color)
  if color == "Black" then
    Player[color].broadcast("Please switch colors before attempting to join the codemaster queue.", redColor)
    return
  end
  for _, player in ipairs(codemasterQueue) do
    if Player[color].steam_id == player.steam_id then
      if not player.stay then
        player.stay = true
        redrawQueue()
      end
      return
    end
  end
  local playerInfo =
  {
    steam_id   = Player[color].steam_id,
    steam_name = Player[color].steam_name,
    stay       = true
  }
  table.insert(codemasterQueue,playerInfo)
  redrawQueue()
end

function leaveQueue(o, color)
  if color == "Black" then
    return
  end
  for i, player in ipairs(codemasterQueue) do
    if Player[color].steam_id == player.steam_id then
      table.remove(codemasterQueue, i)
      break
    end
  end
  redrawQueue()
end

function afkCheckLoop()
  if settings.afkDetection.enabled then
    --print(tostring(os.time()))
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local players = Player.getPlayers()
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((settings.afkDetection.threshold * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end
end

function toggleAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.afkDetection.enabled = not settings.afkDetection.enabled
    Timer.destroy("afkLoop")
    if settings.afkDetection.enabled then
      Timer.create({
        identifier     = "afkLoop",
        function_name  = "afkCheckLoop",
        function_owner = self,
        delay          = 1,
        repetitions    = 0
      })
    end
    drawSettingsCP()
  end
end

function cluemasterEncode(object, playerColor, input, selected)
  if (playerColor == "Blue" and object.guid == blueEncoding.guid) or (playerColor == "Red" and object.guid == redEncoding.guid) then
    -- Handle encoding
    if string.match(input, "\n") and selected then
      -- Make sure that it's the current codemaster's turn
      if (playerColor == "Blue" and turnTracker == 0) or (playerColor == "Red" and turnTracker == 1) then
        Player[playerColor].broadcast("It's not your turn to enter a clue.", redColor)
        return ""
      end

      local processedClue = processClue(input)
      if processedClue != nil then
        local clue, number = getClueDetails(processedClue)
        if clue != nil and number != nil then
          if number != "inf" and tonumber(number) > 9 then
            Player[playerColor].broadcast("Clues cannot be for more than 9 words.", redColor)
            return ""
          elseif string.len(clue) > 20 then
            Player[playerColor].broadcast("Clues cannot be longer than 20 characters.", redColor)
            return ""
          else
            -- Disable for now until I get Google TTS working
            --playClue(playerColor, clue, number)
            if number == "inf" then
              number = "∞"
              guessesLeft = -1
            elseif number == "0" then
              guessesLeft = -1
            else
              guessesLeft = tostring(number) + 1
            end
            encodeClue(playerColor, clue .. " - " .. number)
            local timerID = tostring(math.random())
            Timer.create({
              identifier     = timerID,
              function_name  = "delayDrawEncodeInput",
              function_owner = self,
              parameters     = {id = timerID, obj = object},
              delay          = 0.25
            })
            if not analytics.optOut then
              local payload =
              {
                a = "c",
                g = tostring(analytics.g),
                c = tostring(clue),
                n = tostring(number == "∞" and -1 or number),
                cm = tostring(Player[playerColor].steam_id)
              }
              WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "nullCallback")
            end
            return ""
          end
        else
          Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
          return ""
        end
      else
        Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
        return ""
      end
    end
  else
    -- Player does not have permission
    local team = ""
    if object.guid == redEncoding.guid then
      team = "red"
    elseif object.guid == blueEncoding.guid then
      team = "blue"
    end

    if selected then
      if team != "" then
        Player[playerColor].broadcast("You don't have permission to make clues for the " .. team .. " team!", redColor)
      else
        -- Generic error message
        Player[playerColor].broadcast("You don't have permission to make clues here!", redColor)
      end
      return ""
    end
  end
end

function playClue(team, clue, number)
  local message
  if number == "inf" then
    message = "The " .. team .. " team's code is, " .. clue .. ", with infinite guesses."
  elseif number == "0" then
    message = "The " .. team .. " team's code is to avoid, " .. clue .. ", with infinite guesses."
  else
    message = "The " .. team .. " team's code is, " .. clue .. ", for " .. number
    if number == "1" then
      message = message .. " word."
    else
      message = message .. " words."
    end
  end
  if not analytics.optOut then
    local payload = {
      msg = message,
      voice = "Chris",
      engine = "1"
    }
    WebRequest.post("https://www.lumenvox.com/products/tts/processTTS.ashx", payload, self, "playClueCallback")
  end
end

function playClueCallback(returnData)
  if returnData.is_done then
    local mediaFile = string.match(returnData.text, "^.+<path>(.+)</path>.+$")
    if mediaFile != nil then
      -- Ensure that the returned media file was able to be found in the return XML
      clueTablet.setValue("https://ryan6578.com/tabletopsimulator/codenames/codenames.php?tts=" .. mediaFile)
    end
  end
end

function processClue(clue)
  local result, status, error
  if clue == "" then
    -- Clue is empty
    return nil
  end

  status, result = pcall(function() return string.lower(string.gsub(clue, "\n", "")) end)
  if status != true then
    -- Error whilst removing newline
    return nil
  end

  status, result = pcall(function() return string.match(clue, "%s*(.-)%s*$") end)
  if status != true then
    -- Error whilst trimming clue
    return nil
  end

  -- No errors occured - return the formatted clue
  return string.lower(result)
end

function getClueDetails(processedClue)
  -- How many hyphens are there?
  local clue, number
  local _, hyphenCount = string.gsub(processedClue, "%-", "")
  local _, spaceCount = string.gsub(processedClue, "%s", "")

  if hyphenCount == 0 then
    -- Single word with space (or no space) as delimiter
    if spaceCount > 1 then
      return nil, nil
    end

    local checks = {
      "^(%a+)(%s*)(%d+)$",
      "^(%a+)(%s+)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 1 then
    -- Either a hypenated word with a space (or no space) as delimiter
    -- or a single word with a hyphen (and possibly spaces) as delimiter
    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*)(%d+)$",
      "^(%a+%-%a+)(%s+)(inf)$",
      "^(%a+)(%s*%-%s*)(%d+)$",
      "^(%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 2 then

    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*%-%s*)(%d+)$",
      "^(%a+%-%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  else
    -- Clue has too many hyphens
    return nil, nil
  end
end

function rotateclues()
  local objectsInZone = clueZone.getObjects()
  for i, object in ipairs(objectsInZone) do
    local tag = object.tag
    if tag =="Card" then
      object.setRotation({0, 180, 0})
    end
  end
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local clueColor
  local broadcastTo
  if color == "Red" then
    clueColor = redColor
    finishedClue = redToken.clone({
      position     = redToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if redCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (redCluesTracker - 1) do
        if redClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = redClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        redCluesTracker = 0
        redClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            redCluesTracker = redCluesTracker + 1
          end
        end
      end
    end

    -- Set the red clue position
    redClues[redCluesTracker] = finishedClue
    cluePosition = {-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))}
    redCluesTracker = redCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Orange", "Yellow", "Pink", "Brown"}
  elseif color == "Blue" then
    clueColor = blueColor
    finishedClue = blueToken.clone({
      position     = blueToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if blueCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (blueCluesTracker - 1) do
        if blueClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = blueClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        blueCluesTracker = 0
        blueClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            blueCluesTracker = blueCluesTracker + 1
          end
        end
      end
    end

    -- Set the blue clue position
    blueClues[blueCluesTracker] = finishedClue
    cluePosition = {20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))}
    blueCluesTracker = blueCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Teal", "Purple", "Green", "White"}
  end

  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition(cluePosition)
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.setLuaScript(
    "function onload()\n"
      .. "self.createButton({\n"
        .. "label='" .. clue .. "', click_function='nullFunction', function_owner=self,\n"
        .. "position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}\n"
      .. "})\n"
    .. "end\n"

    .. "function nullFunction()\n"
    .. "end\n"
  )
  printToAll(color .. " team's clue is: " .. clue, clueColor)
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("Your clue is: " .. clue, clueColor)
  end
end

function toggleAmbi()
  -- Deprecate until further notice
  --[[if ambientlights == 1 then

    ambientlights = 0

    ambient_bot.setPositionSmooth({0, -35, -26})
    ambient_top.setPositionSmooth({0, -35, 26})

  elseif ambientlights == 0 then

    ambientlights = 1

    ambient_bot.setPositionSmooth({0, 4.68, -26})
    ambient_top.setPositionSmooth({0, 4.68, 26})

  end]]
end

function toggleTeams()
  -- Deprecate until further notice
  --[[if teamlights == 1 then

    teamlights = 0

    teams_red.setPositionSmooth({-44, -35, 0})
    teams_blue.setPositionSmooth({44, -35, 0})
  elseif teamlights == 0 then

    teamlights = 1

    teams_red.setPositionSmooth({-44, 4.68, 0})
    teams_blue.setPositionSmooth({44, 4.68, 0})

  end]]
end

function toggleTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.timer.enabled = not settings.timer.enabled
    if settings.timer.enabled then
      startTime()
      printToAll("Timer Enabled", {1,1,1})
    else
      if gameStarted then
        clockTimer.setValue(0)
      end
      printToAll("Timer Disabled", {1,1,1})
    end
    drawSettingsCP()
  end
end

function deleteclues()
  -- Delete red clues
  for _, redClue in pairs(redClues) do
    redClue.destruct()
  end
  redClues = {}
  redCluesTracker = 0

  -- Delete blue clues
  for _, blueClue in pairs(blueClues) do
    blueClue.destruct()
  end
  blueClues = {}
  blueCluesTracker = 0
end

function onPlayerDisconnect(player)
  for i, queuePlayer in ipairs(codemasterQueue) do
    if queuePlayer.steam_id == player.steam_id then
      table.remove(codemasterQueue, i)
      break
    end
  end
  redrawQueue()
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team ="Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team ="None"
    end
  end

  -- Change keymap color if necessary
  local zoneColor = keymapZone.getValue()
  if color == "Blue" and zoneColor != "Blue" then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif color == "Red" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  -- Tell players which team they are on
  if color =="Red" or color =="Orange" or color =="Yellow" or color =="Pink" or color =="Brown" then
    Player[color].broadcast("You are team RED.", {0.856, 0.1, 0.094})
    --announceTeam(color)
  elseif color == "Blue" or color =="Teal" or color =="Purple" or color =="Green" or color =="White" then
    Player[color].broadcast("You are team BLUE.", {0.118, 0.53, 1})
    --announceTeam("Blue", color)
  end

  if not shufflingPlayers then
    for _, player in ipairs(Player.getPlayers()) do
      if player.color == "Black" or player.color == "Grey" then
        for i, queuePlayer in ipairs(codemasterQueue) do
          if player.steam_id == queuePlayer.steam_id then
            table.remove(codemasterQueue, i)
            break
          end
        end
      end
    end
    redrawQueue()
  end
end

function announceTeam(color)
  -- Stop the UI element from showing - buggy
  --[[local attributes = {
    active = false,
    visibility = color
  }
  UI.setAttributes(color .. "Announce", attributes)

  if announceTracker[color] != nil then
    UI.hide(color .. "Announce")
    Timer.destroy(announceTracker[color])
  end]]
  Timer.destroy(color .. "Welcome")
  UI.setAttribute(color .. "Welcome", "active", "false")
  local params = {}
  params.id = color .. "Welcome"
  Timer.create({identifier=params.id, function_name='announceStart', parameters=params, delay=1})
end

function announceStart(params)
  print("Announce started")
  Timer.destroy(params.id)
  local id = params.id
  UI.show(id)
  --UI.setAttribute(id, "active", "true")
  Timer.create({identifier=params.id, function_name='announceEnd', parameters=params, delay=5})
end

function announceEnd(params)
  print("Announce ended")
  Timer.destroy(params.id)
  local id = params.id
  UI.hide(id)
  --UI.setAttribute(id, "active", "false")
end

function startTime()
  if settings.timer.enabled and gameStarted then
    if firstTurn then
      clockTimer.setValue(settings.timer.initial * 60)
    else
      clockTimer.setValue(settings.timer.subsequent * 60)
    end
    clockTimer.Clock.pauseStart()
  end
end

-- Deck fetching
function fetchDeck(deck)
  local chosenDeck = decks[deck]

  -- Hybrid loading - load a new deck if one doesn't exist
  if chosenDeck.tag == "Infinite" then
    local spawnedDeck = chosenDeck.takeObject({
      position  = {-9.72, -2, 17.99},
      rotation  = {0, 180, 180},
      smooth    = false
    })
    spawnedDeck.setLock(true)
    spawnedDeck.interactable = false
    chosenDeck = spawnedDeck
    decks[deck] = spawnedDeck
  end

  if chosenDeck != nil then
    local deck = chosenDeck.clone({
      position     = {-9.72, 3, 17.99},
      snap_to_grid = true
    })
    deck.setLock(false)
  end
end

-- Clear decks from dealer zone
function clearDeckZone(deckZone)
  local objectsInZone = deckZone.getObjects()
  for i, object in ipairs(objectsInZone) do
  local tag = object.tag
  if tag =="Deck" then
    destroyObject(object)
  end
end
end

-- Call functions get deck + clear deckZone
function resetVanilla(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(1)
  end
end

function resetHanii(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(2)
  end
end

function resetCHRY(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(3)
  end
end

function resetUndercover(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(4)
  end
end

function resetSaydi(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(5)
  end
end

function resetMayor(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(6)
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function newGame(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if newGameStarting == false then
      local deckFound = findDeck()
      if deckFound then
        newGameStarting = true
        reset_agentLocations()
        deleteclues()
        local payload =
        {
          a = "s",
          h = tostring(analytics.h),
          d = tostring(analytics.d)
        }
        WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "setG")
      else
        Player[color].broadcast("You need to choose a deck before starting.", redColor)
      end
    else
      Player[color].broadcast("A new game is already starting. Please wait.", redColor)
    end
  end
end

function setG(g)
  if g.is_done then
    analytics.g = g.text
  end
end

function nullCallback(null)
end

-- Find deck on top of deck dealer
function findDeck()
    local deckObjects = deckZone.getObjects()
    local toolPos = deckDealer.getPosition()
    local toolPosX = toolPos.x
    local toolPosZ = toolPos.z

    for i, v in pairs(deckObjects) do
        if v.tag == "Deck" then
            local vPos = v.getPosition()
            local vPosX = vPos.x
            local vPosZ = vPos.z
            local dX = toolPosX - vPosX
            local dZ = toolPosZ - vPosZ
            if dX<1 and dX>-1 and dZ<1 and dZ>-1 then
              clearZone(zoneToClear)
              analytics.d = v.getName()
              -- Shuffle players
              if settings.playerShuffle then
                cardsToDeal = v
                startLuaCoroutine(Global, "startShuffle")
              elseif settings.codemasterQueue then
                cardsToDeal = v
                startLuaCoroutine(Global, "swapCodemasters")
              else
                dealCards(v)
                reset_keymap()
              end
              return true
            end
        end
    end
    return false
end

-- Deals out cards from deck dealer
function dealCards(deck)
      deck.shuffle()
      local draw_parameters = {}
      draw_parameters.rotation = {0, 180, 0}
      draw_parameters.flip = true
      draw_parameters.top = true

      for i, pos in ipairs(codeLocations) do
          draw_parameters.position = pos
          local c = deck.takeObject(draw_parameters)
          cardsInPlayArea[i] = c
          local cPos = c.getPosition()
          c.setLuaScript([[
          function onLoad()]]
            .. "local timeSet =" .. os.time()
            .. "position = {"
            .. pos.x .. ", "
            .. pos.y .. ", "
            .. pos.z ..
            [[}
            rotation = {0, 180, 0}
            if os.time() - timeSet > 5 then
              self.setPosition(position)
              self.setRotation(rotation)
            end
          end

          function onCollisionEnter(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
              if e != 'Surface' then
                self.setPosition(position)
                self.setRotation(rotation)
              end
            end
          end

          function onCollisionStay(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
              if e != 'Surface' then
                self.setPosition(position)
                self.setRotation(rotation)
              end
            end
          end

          function onCollisionExit(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
                if e != 'Surface' then
                  self.setPosition(position)
                  self.setRotation(rotation)
                end
            end
          end

          function getObject(info)
            return info.collision_object.tag
          end
          ]])
    end
end

-- Zone clearing
function clearZone(zoneToClear)
  local objectsInZone = zoneToClear.getObjects()
  for i, object in ipairs(objectsInZone) do
  local tag = object.tag
  if tag =="Card" then
    destroyObject(object)
  end
end
end

function does_table_have_key( passed_table, passed_key )
-- checks for something in the keys (NOT the values) of a table
    for key,_ in pairs (passed_table) do
        if key == passed_key then
            return true
        end
    end
    return false
end

-- Reset the keymap
function reset_keymap()
  -- Reset game variables
  illegalMove = false
  guessesLeft = -1
  correctTracker = {}
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  local keymap_blue = getObjectFromGUID('65241e')
  local keymap_red = getObjectFromGUID('2ae07d')
  local keymaps = { keymap_blue, keymap_red }

  -- blue goes first = 1, red = 2
  first_random = math.random(2)

  -- put unused keymaps away under the table
  keymap_blue.lock()
  keymap_blue.setRotation( { 0, 0, 0 } )
  keymap_blue.setPosition( { 4, -0.1, 32.4 } )
  keymap_red.lock()
  keymap_red.setRotation( { 0, 0, 0 } )
  keymap_red.setPosition( { -4, -0.1, 32.4 } )

  -- put the keymap corresponding to the first turn team into position
  keymaps[first_random].setRotation( { 0, 0, 0 } )
  keymaps[first_random].setPosition( { 0, 1, -8.4 } )


  local keytile_GUIDs = { 'c7714b', 'c9ec6d', 'edd6a9', '67bb78', '53ea7a', '05e6cf', '03914a', 'e9fbf9', '50a4b1', '181f86', '94bac7', 'c68ce5', '40ca87', 'ad6ced', '29164d', '707d2b', 'e24dad', 'b64b2f', '77f492', '1ee4bf', '5b8638', 'a90289', 'a54e5b', 'd417b5', '6cb9ba' }

  local keytileColors = {
    -- Red keytiles
    ['ad6ced'] = 'red',
    ['c68ce5'] = 'red',
    ['e24dad'] = 'red',
    ['40ca87'] = 'red',
    ['181f86'] = 'red',
    ['94bac7'] = 'red',
    ['29164d'] = 'red',
    ['707d2b'] = 'red',

    -- Blue keytiles
    ['05e6cf'] = 'blue',
    ['edd6a9'] = 'blue',
    ['03914a'] = 'blue',
    ['67bb78'] = 'blue',
    ['53ea7a'] = 'blue',
    ['c9ec6d'] = 'blue',
    ['e9fbf9'] = 'blue',
    ['50a4b1'] = 'blue',

    -- White keytiles
    ['a54e5b'] = 'white',
    ['1ee4bf'] = 'white',
    ['b64b2f'] = 'white',
    ['d417b5'] = 'white',
    ['5b8638'] = 'white',
    ['a90289'] = 'white',
    ['77f492'] = 'white',

    -- Black keytile
    ['c7714b'] = 'black'

    -- Red/Blue keytile
    --['6cb9ba'] = 'redblue'
  }

  -- tile positions on grid are
  -- ~ x = { -2, -1, 0, 1, 2 }
  -- ~ y = 1.23689770698547
  -- ~ z = { -6.4, -7.4, -8.4, -9.4, -10.4 }
  local x_base = -2
  local x_step = 1
  local z_base = -6.4
  local z_step = 1
  local random_list = shuffle_table({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25})
  local index = 0
  for pos, _ in pairs(keymap) do
      local current_keytile = getObjectFromGUID(keytile_GUIDs[random_list[index+1]])
      local x = x_base  +  x_step * (index%5)
      local y = 1.23689770698547
      local z = z_base  -  z_step * math.floor(index/5)
      if current_keytile.guid == "6cb9ba" then
        -- This is the red/blue keytile set based on calculated first_random
        if first_random == 1 then
          -- Blue goes first
          keymap[pos] = 'blue'
          turnTracker = 1
        else
          -- Value is 2 and red goes first
          keymap[pos] = 'red'
          turnTracker = 0
        end
      else
        keymap[pos] = keytileColors[current_keytile.guid]
      end
      current_keytile.lock()
      current_keytile.setRotation( {0,0,0} )
      current_keytile.setPosition( {x,y,z} )
      index = index + 1
  end

  -- flip the extra tile blue side if blue goes first
  if first_random == 1 then
      local double_tile = getObjectFromGUID('6cb9ba')
      double_tile.setRotation( {0, 0, 180 } )
      -- move it upwards by its own depth because flipping changes position
      local double_tile_position = double_tile.getPosition()
      double_tile.setPosition({double_tile_position.x, double_tile_position.y+0.1, double_tile_position.z })
  end
  setDoubleTimer()
end

function shuffle_table( passed_table )
-- fisher-yates shuffle

    for current_index = #passed_table, 1, -1 do
        local swap_index = math.random(#passed_table)
        passed_table[current_index], passed_table[swap_index] = passed_table[swap_index], passed_table[current_index]
    end
    return passed_table

end

function setDoubleTimer()
  Timer.destroy("waitfortilereset")
  Timer.create({identifier="waitfortilereset", function_name='setDouble', delay=1})
end

function setDouble()
  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  if first_random == 1 then
    -- Set the correct double card to blue
    doubleBlue.setLock(false)
    doubleBlue.setPosition(agentLocations[doubleBlue.guid])
    doubleBlue.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  elseif first_random == 2 then
    -- Set the correct double card to red
    doubleRed.setLock(false)
    doubleRed.setPosition(agentLocations[doubleRed.guid])
    doubleRed.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(redRot)
    buttonTeams.setPosition(redPos)
    printToAll("Red team's turn.", redColor)
  end

  -- Change the gameStarted to 1
  gameStarted = true

  -- Start the timer
  firstTurn = true
  startTime()

  -- Game has successfully started
  newGameStarting = false
end

function reset_agentLocations()
  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  -- resets the agent cards to their start positions
  for guid, pos in pairs(agentLocations) do
    local card = getObjectFromGUID(guid)
    if card then
      if card.guid == doubleRed.guid then
        doubleRed.interactable = false
        doubleRed.setLock(true)
        doubleRed.setPosition({0, -2, -14})
      elseif card.guid == doubleBlue.guid then
        doubleBlue.interactable = false
        doubleBlue.setLock(true)
        doubleBlue.setPosition({0, -2, -14})
      else
        card.setPosition(pos)
        card.setRotation({0,180,180})
        card.unlock()
        card.interactable = true
      end
    end
  end
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if agentLocations[agent.guid] == nil then
    return
  end

  local codeObjects = clueZone.getObjects()
  local agentPos = agent.getPosition()
  local searchThreshold = 1
  for _, code in pairs(codeObjects) do
    local codePos = code.getPosition()
    local dX = math.abs(agentPos.x - codePos.x)
    local dZ = math.abs(agentPos.z - codePos.z)
    if code.guid != agent.guid and code.tag == "Card" and dX<searchThreshold and dZ<searchThreshold then
      -- Orient cards properly
      code.setRotationSmooth({0, 180, 0})
      agent.setRotationSmooth({0, 180, 180})

      -- Check to see if the agent card was placed correctly, but only if placed by blue or red
      if color == "Red" or color == "Blue" then
        --If illegal condition is set, dont allow for any more placing
        if illegalMove then
          agent.setPositionSmooth(agentTracker[agent.guid])
          return
        end

        local roundedPos = {x = round(codePos.x, 2), z = round(codePos.z, 2)}
        local codeColor = checkLocation(roundedPos)
        local agentColor = agentColors[agent.guid]

        if codeColor == agentColor then
          -- Card was placed correctly
          if correctTracker[roundedPos.x .. roundedPos.z] == nil then
            correctTracker[roundedPos.x .. roundedPos.z] = agent.guid
            code.interactable = false
            agent.interactable = false
            local lockParam = {}
            lockParam.agent = agent
            lockParam.code = code
            lockParam.id = tostring(math.random())
            Timer.create({identifier=lockParam.id, function_name='lockCorrect', parameters=lockParam, delay=1})
            -- Check to see if one team has won
            local redWon = true
            local blueWon = true

            for guid, agtColor in pairs(agentColors) do
              if agtColor == "red" then
                if first_random == 1 and guid == "3ef1ca" then
                  -- Red double agent not in use
                elseif getObjectFromGUID(guid).interactable then
                  redWon = false
                end
              elseif agtColor == "blue" then
                if first_random == 2 and guid == "1e9282" then
                  -- Blue double agent not in use
                elseif getObjectFromGUID(guid).interactable then
                  blueWon = false
                end
              end

              -- Skip unnecessary iterations
              if redWon == false and blueWon == false then
                break
              end
            end
            -- Four scenarios:
            -- 1) white - done
            -- 2) opposite color - done
            -- 3) Black
            -- 4) Correct
            -- If card is white, or card is of the opposite color, then toggle toggleTurns
            -- 0 = RED; 1 = BLUE
            guessesLeft = guessesLeft - 1
            if codeColor == "black" or blueWon or redWon then
              -- End game scenario
              if (codeColor == "black" and turnTracker == 0) or blueWon then
                -- Red placed black card, blue wins
                -- or blue placed all of their cards
                broadcastToAll("Blue team wins!", blueColor)
              elseif (codeColor == "black" and turnTracker == 1) or redWon then
                -- Blue placed black card, red wins
                -- or red placed all of their cards
                broadcastToAll("Red team wins!", redColor)
              end

              -- Set the game back to initial state
              gameStarted = false

              -- Set the timer to 0 and disable
              clockTimer.setValue(0)

              -- Move the remaining agents to their codes
              endGame()
              if not analytics.optOut then
                local payload =
                {
                  a = "e",
                  g = tostring(analytics.g)
                }
                WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "nullCallback")
              end
            elseif guessesLeft == 0 or codeColor == "white" or (codeColor == "red" and turnTracker == 1) or (codeColor == "blue" and turnTracker == 0) then
              toggleTurns()
            end
          else
            agent.setPositionSmooth(agentTracker[agent.guid])
            Player[color].broadcast("This code has already been marked correctly.", redColor)
          end
        else
          -- Card was placed incorrectly
          illegalMove = true
        end
      else
        -- Move the placed card back to its original position
        agent.setPositionSmooth(agentTracker[agent.guid])
        Player[color].broadcast("Only codemasters are able to place agent cards.", redColor)
      end
    end
  end
end

function lockCorrect(params)
  local agent = params.agent
  local code = params.code
  agent.setLock(true)
  code.setLock(true)

  -- Ensure the tile is on the code
  agent.setPosition(code.getPosition())
  agent.setRotation({0, 180, 180})

  Timer.destroy(params.id)

  local ensureParam = {}
  ensureParam.id = math.random()
  ensureParam.agent = agent
  ensureParam.position = code.getPosition()

  Timer.create({identifier=ensureParam.id, function_name='ensurePos', parameters=ensureParam, delay=1})
end

function ensurePos(params)
  local agent = params.agent

  agent.setPosition(params.position)
  agent.setRotation({0, 180, 180})

  Timer.destroy(params.id)
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" then
    local clues = clueZone.getObjects()
    local position = object.getPosition()
    for i, v in pairs(clues) do
      if v.guid == object.guid and v.tag == "Card" then
        -- Prevent picking up of codes
        for _, card in ipairs(cardsInPlayArea) do
          if card.guid == object.guid then
            object.reload()
            break
          end
        end
      end
    end
  elseif object.tag == "Tile" and agentLocations[object.guid] != nil then
    -- Track the original locations of the tiles
    local tileZoneObj = tileZone.getObjects()
    for _, obj in pairs(tileZoneObj) do
      if obj.guid == object.guid then
        agentTracker[object.guid] = object.getPosition()
      end
    end

    -- Prevent picking up of agent tiles from anyone but red or blue
    if color != "Blue" and color != "Red" then
      for guid,_ in pairs(agentLocations) do
        if guid == object.guid then
          --object.reload()
        end
      end
    end
  end

  -- Agent dealCards
  if illegalMove and object.tag == "Tile" and agentColors[object.guid] != nil then
    -- Only check entire board if an error condition exists
    local boardIsCorrect = true
    local placedTiles = clueZone.getObjects()
    for _, v in pairs(placedTiles) do
      if v.guid != object.guid and v.tag == "Tile" and agentLocations[v.guid] != nil then
        local agtPos = v.getPosition();
        if checkLocation({x = agtPos.x, z = agtPos.z}) != agentColors[v.guid] then
          boardIsCorrect = false;
        end
      end
    end
    if boardIsCorrect then
      illegalMove = false
    end
  end
end

function endGame()

  local codesLeft = {}

  local blueAgentsLeft = {}
  local blueNum = 1
  local redAgentsLeft = {}
  local redNum = 1
  local whiteAgentsLeft = {}
  local whiteNum = 1
  local blackAgentsLeft = {}

  local numCodes = 0

  -- Get the remining codes left
  for i, pos in ipairs(codeLocations) do
    if correctTracker[pos.x .. pos.z] == nil then
      codesLeft[#codesLeft+1] = pos
      numCodes = numCodes + 1
    end
  end

  -- Get the remaining agent cards
  for guid, agtColor in pairs(agentColors) do
    if agtColor == "red" then
      if first_random == 1 and guid == "3ef1ca" then
        -- Red double agent not in use
      elseif getObjectFromGUID(guid).interactable then
        redAgentsLeft[#redAgentsLeft+1] = guid
      end
    elseif agtColor == "blue" then
      if first_random == 2 and guid == "1e9282" then
        -- Blue double agent not in use
      elseif getObjectFromGUID(guid).interactable then
        blueAgentsLeft[#blueAgentsLeft+1] = guid
      end
    elseif agtColor == "white" and getObjectFromGUID(guid).interactable then
      whiteAgentsLeft[#whiteAgentsLeft+1] = guid
    elseif agtColor == "black" and getObjectFromGUID(guid).interactable then
      blackAgentsLeft[#blackAgentsLeft+1] = guid
    end
  end

  local timeDelay = 0

  for _, pos in ipairs(codesLeft) do
    local posColor = checkLocation(pos)

    if posColor == "red" then
      agent = getObjectFromGUID(redAgentsLeft[redNum])
      redNum = redNum + 1
    elseif posColor == "blue" then
      agent = getObjectFromGUID(blueAgentsLeft[blueNum])
      blueNum = blueNum + 1
    elseif posColor == "white" then
      agent = getObjectFromGUID(whiteAgentsLeft[whiteNum])
      whiteNum = whiteNum + 1
    elseif posColor == "black" then
      agent = getObjectFromGUID(blackAgentsLeft[1])
    end

    local clues = clueZone.getObjects()
    local object = agent
    local cardX = pos.x
    local cardZ = pos.z
    local searchThreshold = 0.90
    for i, v in pairs(clues) do
      local vPos = v.getPosition()
      local vPosX = vPos.x
      local vPosZ = vPos.z
      local dX = cardX - vPosX
      local dZ = cardZ - vPosZ
      if v.guid != agent.guid and v.tag == "Card" and dX<searchThreshold and dX>-searchThreshold and dZ<searchThreshold and dZ>-searchThreshold then
        -- Orient cards properly
        local endParam = {}
        endParam.id = math.random()
        endParam.agent = agent
        endParam.code = v
        endParam.pos = pos

        Timer.create({identifier=endParam.id, function_name='endCardSet', parameters=endParam, delay=timeDelay})
      end
    end
    timeDelay = timeDelay + 0.15
  end
end

function endCardSet(endParam)
  local code = endParam.code
  local agent = endParam.agent
  local pos = endParam.pos

  code.interactable = false;
  agent.interactable = false;
  code.setLock(true)
  code.setRotationSmooth({0, 180, 0})
  agent.setRotation({0, 180, 180})
  agent.setPositionSmooth(pos)
  agent.setLock(true)

  Timer.destroy(endParam.id)
end

function onUpdate()
  -- Check for clock rundown if timer is enabled
  if settings.timer.enabled and newGameStarting == false and gameStarted and illegalMove == false then
    local timerVal = clockTimer.getValue()
    if timerVal == 0 then
      -- Switch turns
      timerWarning = timerVal
      broadcastToAll("Time's up!", redColor)
      toggleTurns()
    elseif timerVal == 60 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll("1 minute remaining!", redColor)
    elseif timerVal <= 5 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll(timerVal .. " seconds remaining!", redColor)
    end
  end

  -- Notify codemasters of illegal move
  if illegalMove then
    if updateTimer == 100 then
      Player["Blue"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      Player["Red"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      updateTimer = 0
    else
      updateTimer = updateTimer + 1
    end
  end
end

function checkLocation(position)
  for pos,color in pairs(keymap) do
    if pos == (tostring(round(position.x, 2)) .. "," .. tostring(round(position.z, 2))) then
      return color
    end
  end
end

function round(exact, precision)
   return math.floor(exact*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function toggleTurns()
  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  firstTurn = false

  -- Reset the guesses each team has left
  guessesLeft = -1

  if turnTracker == 0 then
    -- Red team's turn ends, switch to blue team
    turnTracker = 1
    buttonRed.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  else
    -- Blue team's turn ends, switch to red team
    turnTracker = 0
    buttonBlu.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  rotateclues()

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    if illegalMove == false then
      -- Is it the current side's turn?
      if turnTracker == 0 and button.guid == buttonBlu.guid or turnTracker == 1 and button.guid == buttonRed.guid then
        --Player[color].print("It's not your turn!")
        return
      end

      -- Reset the timer warning
      timerWarning = -1

      -- Make sure it isn't the first turn
      firstTurn = false

      -- Reset the guesses each team has left
      guessesLeft = -1

      if turnTracker == 0 then
        -- Red team's turn ends, switch to blue team
        turnTracker = 1
        buttonRed.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(blueRot)
        buttonTeams.setPositionSmooth(bluePos)
        printToAll("Blue team's turn.", blueColor)
      else
        -- Blue team's turn ends, switch to red team
        turnTracker = 0
        buttonBlu.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(redRot)
        buttonTeams.setPositionSmooth(redPos)
        printToAll("Red team's turn.", redColor)
      end

      rotateclues()

      startTime()

    else
      -- Notify the person trying to end the turn that there are cards incorrectly placed on the board
      Player[color].broadcast("Please fix the incorrectly placed agent cards before ending your turn.", redColor)
    end
  end
end
