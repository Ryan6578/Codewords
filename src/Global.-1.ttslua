--[[

  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2018  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

]]

disclaimer =
[[
This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. You may, at your own
discretion, opt out of this data collection
via the checkbox below.

More info:
[8bb5ff]https://ryan6578.com/codenames/stats/privacy[-]

Statistics:
[8bb5ff]https://ryan6578.com/codenames/stats[-]
]]

chatDisclaimer =
[[

                  [da1918]ANALYTICS DISCLAIMER[-]
[-]This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. By continuing, you
acknowledge and accept this in accordance
with the privacy policy outlined below.

More info:
[8bb5ff]https://ryan6578.com/codenames/stats/privacy[-]

Statistics:
[8bb5ff]https://ryan6578.com/codenames/stats[-]

]]

redColor = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}

codeLocations =
{
  { x = -11.4, y = 1.03, z = 12.6 }, { x = -5.7, y = 1.03, z = 12.6 }, { x = 0, y = 1.03, z = 12.6 }, { x = 5.7, y = 1.03, z = 12.6 }, { x = 11.4, y = 1.03, z = 12.6 },
  { x = -11.4, y = 1.03, z = 8.75 }, { x = -5.7, y = 1.03, z = 8.75 }, { x = 0, y = 1.03, z = 8.75 }, { x = 5.7, y = 1.03, z = 8.75 }, { x = 11.4, y = 1.03, z = 8.75 },
  { x = -11.4, y = 1.03, z = 4.9  }, { x = -5.7, y = 1.03, z = 4.9  }, { x = 0, y = 1.03, z = 4.9  }, { x = 5.7, y = 1.03, z = 4.9  }, { x = 11.4, y = 1.03, z = 4.9  },
  { x = -11.4, y = 1.03, z = 1.05 }, { x = -5.7, y = 1.03, z = 1.05 }, { x = 0, y = 1.03, z = 1.05 }, { x = 5.7, y = 1.03, z = 1.05 }, { x = 11.4, y = 1.03, z = 1.05 },
  { x = -11.4, y = 1.03, z = -2.8 }, { x = -5.7, y = 1.03, z = -2.8 }, { x = 0, y = 1.03, z = -2.8 }, { x = 5.7, y = 1.03, z = -2.8 }, { x = 11.4, y = 1.03, z = -2.8 }
}

agentLocations =
{
  -- Assassain
  ['b97df2']={ 0.04, 2, -17.84 };
  -- Blue agents
  ['7fdaee']={ 12.34, 2, -13.97 }, ['99832c']={ 18.07, 2, -13.97 }, ['d9324a']={ 23.77, 2, -13.97 }, ['19b2d5']={ 29.47, 2, -13.97 },
  ['0f0ec0']={ 12.34, 2, -17.8  }, ['d9054c']={ 18.07, 2, -17.8  }, ['4de840']={ 23.77, 2, -17.8  }, ['05c73d']={ 29.47, 2, -17.8  };
  -- Red agents
  ['b48ed4']={ -29.32, 2, -13.97 }, ['6bb4d8']={ -23.62, 2, -13.97 }, ['9cbe84']={ -17.92, 2, -13.97 }, ['746660']={ -12.22, 2, -13.97 },
  ['4a2969']={ -29.32, 2, -17.8  }, ['e1754e']={ -23.62, 2, -17.8  }, ['b89ba7']={ -17.92, 2, -17.8  }, ['5c1be6']={ -12.22, 2, -17.8  };
  -- Civialians
  ['f6786b']={ -5.7, 2, -21.7 }, ['e44594']={ -5.7, 2, -17.84 }, ['1f53f2']={ -5.7, 2, -14 },
  ['f8f6a1']={ 0.04, 2, -21.7 },
  ['a05e4e']={ 5.74, 2, -21.7 }, ['1ebedd']={ 5.74, 2, -17.84 }, ['3d7b86']={ 5.74, 2, -14 };
  -- Double agents
  ['1e9282']={ 0.04, 2, -14 };
  ['3ef1ca']={ 0.04, 3, -14 };
}

agentColors =
{
  -- Assassain
  ['b97df2'] = 'black',

  -- Blue agents
  ['7fdaee'] = 'blue',
  ['99832c'] = 'blue',
  ['d9324a'] = 'blue',
  ['19b2d5'] = 'blue',
  ['0f0ec0'] = 'blue',
  ['d9054c'] = 'blue',
  ['4de840'] = 'blue',
  ['05c73d'] = 'blue',

  -- Red agents
  ['b48ed4'] = 'red',
  ['6bb4d8'] = 'red',
  ['9cbe84'] = 'red',
  ['746660'] = 'red',
  ['4a2969'] = 'red',
  ['e1754e'] = 'red',
  ['b89ba7'] = 'red',
  ['5c1be6'] = 'red',

  -- Civialians
  ['f6786b'] = 'white',
  ['e44594'] = 'white',
  ['1f53f2'] = 'white',
  ['f8f6a1'] = 'white',
  ['a05e4e'] = 'white',
  ['1ebedd'] = 'white',
  ['3d7b86'] = 'white',

  -- Double agents
  ['1e9282'] = 'blue',
  ['3ef1ca'] = 'red'
}

size =
{
  -- Small buttons
  small =
  {
    width     = 1800,
    height    = 1200,
    font_size = 340
  },

  -- Medium buttons
  medium =
  {
    width     = 3200,
    height    = 1200,
    font_size = 400
  },

  -- Large buttons
  large =
  {
    width     = 3200,
    height    = 4100,
    font_size = 400
  }
}

buttonColor =
{
  ["Blue"]    = {{31/255, 135/255, 255/255}, {0/255, 109/255, 235/255}, {0/255, 85/255, 184/255}},
  ["Teal"]    = {{33/255, 177/255, 155/255}, {25/255, 134/255, 117/255}, {17/255, 91/255, 79/255}},
  ["Purple"]  = {{160/255, 32/255, 240/255}, {133/255, 14/255, 207/255}, {102/255, 11/255, 159/255}},
  ["Green"]   = {{49/255, 179/255, 43/255}, {38/255, 138/255, 33/255}, {27/255, 97/255, 23/255}},
  ["White"]   = {{255/255, 255/255, 255/255}, {229/255, 229/255, 229/255}, {203/255, 203/255, 203/255}},

  ["Red"]     = {{218/255, 25/255, 24/255}, {172/255, 20/255, 19/255}, {126/255, 15/255, 14/255}},
  ["Orange"]  = {{244/255, 100/255, 29/255}, {212/255, 77/255, 10/255}, {163/255, 59/255, 8/255}},
  ["Yellow"]  = {{231/255, 229/255, 44/255}, {201/255, 199/255, 23/255}, {155/255, 154/255, 18/255}},
  ["Pink"]    = {{245/255, 112/255, 206/255}, {242/255, 64/255, 190/255}, {239/255, 16/255, 174/255}},
  ["Brown"]   = {{133/255, 59/255, 23/255}, {71/255, 37/255, 14/255}, {28/255, 15/255, 6/255}}
}

function onload(saveState)

  -- Global variables --

  -- Global game mode
  gameStarted = false
  firstTurn = true
  -- Keeps track of whether or not a new game is in the process of starting
  newGameStarting = false
  -- Timer warning variable
  timerWarning = -1
  -- 0 = RED; 1 = BLUE
  turnTracker = 1

  settings =
  {
    playerShuffle = false,

    afkDetection =
    {
      enabled   = true,
      threshold = 10
    },

    timer =
    {
      enabled     = true,
      initial     = 10,
      subsequent  = 5
    },

    codemasterQueue = true
  }

  -- Used for game analytics - ryan6578.com
  analyticsLocked = false
  analytics =
  {
    -- Opt out of analytics?
    optOut = false, -- Opt out of analytics if you so wish
    g = "",
    h = "",
    d = ""
  }
  if not analytics.optOut then
    for i, player in ipairs(Player.getPlayers()) do
      if player.host then
        analytics.h = player.steam_id
        break
      end
    end
  end

  -- Illegal move tracking
  updateTimer = 0
  illegalMove = false

  -- Configuration panel settings
  codemasterQueue = {}
  afkTracker = {}

  -- Tracks the amount of guesses the current team has left
  guessesLeft = -1

  -- Keep track of team announcements
  announceTracker = {}

  -- Red clue tracker
  redClues = {}
  redCluesTracker = 0

  -- Blue clue tracker
  blueClues = {}
  blueCluesTracker = 0

  -- Tracks pickup locations of agents
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  -- Tracks correct answers
  correctTracker = {}

  -- Keeps track of the GUIDs of codes in play
  cardsInPlayArea = {}

  -- X, Z coordinates
  keymap = {
    ["-11.4,12.6"] = "", ["-5.7,12.6"] = "", ["0,12.6"] = "", ["5.7,12.6"] = "", ["11.4,12.6"] = "",
    ["-11.4,8.75"] = "", ["-5.7,8.75"] = "", ["0,8.75"] = "", ["5.7,8.75"] = "", ["11.4,8.75"] = "",
    ["-11.4,4.9"] = "", ["-5.7,4.9"] = "", ["0,4.9"] = "", ["5.7,4.9"] = "", ["11.4,4.9"] = "",
    ["-11.4,1.05"] = "", ["-5.7,1.05"] = "", ["0,1.05"] = "", ["5.7,1.05"] = "", ["11.4,1.05"] = "",
    ["-11.4,-2.8"] = "", ["-5.7,-2.8"] = "", ["0,-2.8"] = "", ["5.7,-2.8"] = "", ["11.4,-2.8"] = ""
  }

  -- lights toggles
  spaceBG = getObjectFromGUID("7b8161")
  spaceBG.interactable = false
  spaceParticles = getObjectFromGUID("8430cf")
  spaceParticles.interactable = false
  ambient_bot = getObjectFromGUID("6fb111")
  ambient_bot.interactable = false
  ambient_top = getObjectFromGUID("05032c")
  ambient_top.interactable = false
  teams_red = getObjectFromGUID("a1b2cd")
  teams_red.interactable = false
  teams_blue = getObjectFromGUID("6072b1")
  teams_blue.interactable = false

  -- Control panel declarations
  gameCP = getObjectFromGUID("ec0882")
  gameCP.interactable = false
  settingsCP = getObjectFromGUID("0837df")
  settingsCP.interactable = false
  analyticsCP = getObjectFromGUID("071c46")
  analyticsCP.interactable = false
  queueCP = getObjectFromGUID("c67626")
  queueCP.interactable = false

  drawGameCP()
  drawSettingsCP()
  drawAnalyticsCP()

  deckVanilla = getObjectFromGUID("83b607")
  deckHanii = getObjectFromGUID("92bb6b")
  deckCHRY = getObjectFromGUID("41f57c")
  deckUndercover = getObjectFromGUID("ee8afd")
  deckSaydi = getObjectFromGUID("d75160")
  deckMayor = getObjectFromGUID("3a3e8c")
  deckVanilla.interactable = false
  deckHanii.interactable = false
  deckCHRY.interactable = false
  deckUndercover.interactable = false
  deckSaydi.interactable = false
  deckMayor.interactable = false

  decks = {
    -- Vanilla
    [1] = deckVanilla,

    -- Hanii
    [2] = deckHanii,

    -- CHRY
    [3] = deckCHRY,

    -- Undercover
    [4] = deckUndercover,

    -- Saydi's
    [5] = deckSaydi,

    -- Mayor's
    [6] = deckMayor
  }

  -- Until the clue announcements work
  --clueTablet = getObjectFromGUID("69b440")
  --clueTablet.interactable = false

  deckZone = getObjectFromGUID("33d9ff")

  deckDealer = getObjectFromGUID("27d226")

  -- Keymap zone
  keymapZone = getObjectFromGUID("773642")
  local zoneColor = keymapZone.getValue()
  if Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  zoneToClear = getObjectFromGUID("f71f4c")
  clueZone = getObjectFromGUID("f71f4c")

  buttonRed = getObjectFromGUID("f16a9a")
  buttonBlu = getObjectFromGUID("c91f34")
  buttonTeams = getObjectFromGUID("8a85e8")
  buttonTeams.interactable = false
  buttonTeams.setLock(true)

  -- Red team plaque position and rotation
  redPos = {-20.7, 0.91, 17.94}
  redRot = {0, 180, 0}

  -- Blue team plaque position and rotation
  bluePos = {20.7, 0.91, 17.94}
  blueRot = {0, 180, 180}

  clockTimer = getObjectFromGUID("0b1336")

  tileZone = getObjectFromGUID("06b292")

  buttonBlu.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- red clue encoder
  redToken = getObjectFromGUID("f3cdf2")
  redToken.interactable = false

  -- blue clue encoder
  blueToken = getObjectFromGUID("3f75b3")
  blueToken.interactable = false

  -- Blue encoding station
  blueEncoding = getObjectFromGUID("2ef93a")
  blueEncoding.setLock(true)
  drawEncodeInput(blueEncoding)
  -- Red encoding station
  redEncoding = getObjectFromGUID("7793cd")
  redEncoding.setLock(true)
  drawEncodeInput(redEncoding)

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    gameStarted = decodedSaveState.gameStarted
    settings = decodedSaveState.settings
    timerWarning = decodedSaveState.timerWarning
    turnTracker = decodedSaveState.turnTracker
    first_random = decodedSaveState.first_random

    updateTimer = decodedSaveState.updateTimer
    illegalMove = decodedSaveState.illegalMove

    for pos, guid in pairs(JSON.decode(decodedSaveState.correctTracker)) do
      local agent = getObjectFromGUID(guid)
      if getObjectFromGUID(guid).getLock() == true then
        correctTracker[pos] = guid
        agent.interactable = false
      end
    end

    for i, cardGuid in ipairs(JSON.decode(decodedSaveState.cardsInPlayArea)) do
      cardsInPlayArea[i] = getObjectFromGUID(cardGuid)
    end

    for pos, color in pairs(JSON.decode(decodedSaveState.keymap)) do
      keymap[pos] = color
    end
  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    afkWaitID = Wait.time(afkCheckLoop, 1, -1)
  end
end

function onSave()
  local saveData = {}

  saveData.gameStarted = gameStarted
  saveData.settings = settings
  saveData.timerWarning = timerWarning
  saveData.turnTracker = turnTracker
  saveData.first_random = first_random

  saveData.updateTimer = updateTimer
  saveData.illegalMove = illegalMove

  saveData.correctTracker = JSON.encode(correctTracker)

  local endcodedCardsInPlayArea = {}
  for i, card in ipairs(cardsInPlayArea) do
    endcodedCardsInPlayArea[i] = card.guid
  end
  saveData.cardsInPlayArea = JSON.encode(endcodedCardsInPlayArea)

  saveData.keymap = JSON.encode(keymap)

  return JSON.encode(saveData)
end

function nullFunction()
  -- Nothing
end

function drawEncodeInput(object)
  -- Clear existing inputs
  object.clearInputs()

  -- Draw a new input
  local inputParams =
  {
    input_function  = "cluemasterEncode",
    function_owner  = self,
    tooltip         = "- Enter Clue Here -",
    label           = "- Enter Clue Here -",
    position        = {0, 1, 0},
    rotation        = {0, 180, 0},
    scale           = {0.1, 10, 1/2},
    alignment       = 3,
    width           = 4000,
    height          = 300,
    font_size       = 250,
    value           = ""
  }
  object.createInput(inputParams)
end

function drawGameCP()
  -- Clear all the existing buttons on the CP
  gameCP.clearButtons()

  -- Draw buttons
  makeButton(gameCP, "Vanilla\nCodenames", "resetVanilla", {x = -5.5, z = -3}, false, size.small, nil)
  makeButton(gameCP, "Hanii's\nCodenames", "resetHanii", {x = -5.5, z = 0}, false, size.small, nil)
  makeButton(gameCP, "CHRY's\nCodenames", "resetCHRY", {x = -1.5, z = -3}, false, size.small, nil)
  makeButton(gameCP, "Codenames:\nUndercover", "resetUndercover", {x = -1.5, 0, z = 0}, false, size.small, nil)
  makeButton(gameCP, "Saydi's\nCodenames", "resetSaydi", {x = -5.5, z = 3}, false, size.small, nil)
  makeButton(gameCP, "Mayor's\nCodenames", "resetMayor", {x = -1.5, z = 3}, false, size.small, nil)
  makeButton(gameCP, "New Game\n(Reset)", "newGame", {x = 4, z = 0}, false, size.large, "Green")
end

function drawSettingsCP()
  -- Clear all the existing buttons on the CP
  settingsCP.clearButtons()

  makeText(settingsCP, "Game Settings", {x = -6.75, z = 0}, true, {1, 1, 1}, 500)

  -- Draw the buttons with updated values
  makeCheckbox(settingsCP, "Shuffle Players at Start", "toggleShuffle", {x = -5.5, z = 4.15}, true, 4.2, settings.playerShuffle, false)
  makeCheckbox(settingsCP, "Enable Codemaster Queue", "toggleQueue", {x = -4.3, z = 4.15}, true, 4.6, settings.codemasterQueue, false)
  makeCheckbox(settingsCP, "AFK Detection", "toggleAFK", {x = -3.1, z = 4.15}, true, 2.8, settings.afkDetection.enabled, false)
  makeCounter(settingsCP, settings.afkDetection.threshold, "minutes", "incAFK", "decAFK", {x = -1.9, z = 3.15}, true, 2.5, not settings.afkDetection.enabled)
  makeCheckbox(settingsCP, "Timer Enabled", "toggleTimer", {x = -0.7, z = 4.15}, true, 2.8, settings.timer.enabled, false)
  makeCounter(settingsCP, settings.timer.initial, "minutes (round 1)", "incInitTimer", "decInitTimer", {x = 0.5, z = 3.15}, true, 4.0, not settings.timer.enabled)
  makeCounter(settingsCP, settings.timer.subsequent, "minutes (round 2+)", "incSubTimer", "decSubTimer", {x = 1.7, z = 3.15}, true, 4.2, not settings.timer.enabled)
end

function drawAnalyticsCP()
  -- Clear all the existing buttons on the CP
  analyticsCP.clearButtons()

  -- Draw the disclaimer
  makeText(analyticsCP, "Analytics Disclaimer", {x = 0, z = -4}, false, redColor, 500)
  makeText(analyticsCP, disclaimer, {x = 0, z = 0.35}, false, {1, 1, 1}, 300)

  -- Draw the buttons with updated values
  makeCheckbox(analyticsCP, "[8bff9b]Send usage and statistics[-]", "toggleAnalytics", {x = -4, z = 4}, false, 4.5, not analytics.optOut, analyticsLocked)
end

function makeButton(object, buttonLabel, callback, position, flip, size, colorScheme)
  local attributes =
  {
    click_function  = callback,
    function_owner  = self,
    label           = buttonLabel,
    position        = {x = position.x, y = 0.2, z = position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    width           = size.width,
    height          = size.height,
    font_size       = size.font_size
  }
  if colorScheme != nil then
    attributes.font_color   = {1, 1, 1}
    attributes.color        = buttonColor[colorScheme][1]
    attributes.hover_color  = buttonColor[colorScheme][2]
    attributes.press_color  = buttonColor[colorScheme][3]
  end
  object.createButton(attributes)
end

function makeCheckbox(object, textLabel, callback, position, flip, textOffset, checked, disabled)
  local check =
  {
    label           = (checked and "✔" or ""),
    click_function  = callback,
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 400,
    width           = 400,
    font_size       = 300
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = (flip and {(position.x + 0.1), 0.2, (position.z - textOffset)} or {(position.x + textOffset), 0.2, (position.z + 0.1)}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 350
  }
  if disabled then
    check.color = {0.5, 0.5, 0.5}
    check.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(check)
  object.createButton(text)
end

function makeText(object, contents, position, flip, color, size)
  local text =
  {
    label           = contents,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = color,
    font_size       = size
  }
  object.createButton(text)
end

function makeCounter(object, value, textLabel, incCB, decCB, position, flip, textOffset, disabled)
  local num =
  {
    label           = tostring(value),
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 400,
    width           = 400,
    font_size       = 300
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = (flip and {(position.x + 0.1), 0.2, (position.z - textOffset)} or {(position.x + textOffset), 0.2, (position.z + 0.1)}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 350
  }
  local decrement =
  {
    label           = "-",
    click_function  = decCB,
    function_owner  = self,
    position        = (flip and {position.x, 0.2, (position.z + 0.8)} or {(position.x - 0.8), 0.2, position.z}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  local increment =
  {
    label           = "+",
    click_function  = incCB,
    function_owner  = self,
    position        = (flip and {position.x, 0.2, (position.z - 0.8)} or {(position.x + 0.8), 0.2, position.z}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  if disabled then
    num.color = {0.5, 0.5, 0.5}
    num.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
    decrement.color = {0.5, 0.5, 0.5}
    decrement.font_color = {0.25, 0.25, 0.25}
    increment.color = {0.5, 0.5, 0.5}
    increment.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(num)
  object.createButton(text)
  object.createButton(decrement)
  object.createButton(increment)
end

function decInitTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.initial > 1 then
        settings.timer.initial = settings.timer.initial - 1
        drawSettingsCP()
      end
    end
  end
end

function incInitTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.initial < 20 then
        settings.timer.initial = settings.timer.initial + 1
        drawSettingsCP()
      end
    end
  end
end

function decSubTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.subsequent > 1 then
        settings.timer.subsequent = settings.timer.subsequent - 1
        drawSettingsCP()
      end
    end
  end
end

function incSubTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.subsequent < 20 then
        settings.timer.subsequent = settings.timer.subsequent + 1
        drawSettingsCP()
      end
    end
  end
end

function decAFK(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold > 1 then
        settings.afkDetection.threshold = settings.afkDetection.threshold - 1
        drawSettingsCP()
      end
    end
  end
end

function incAFK(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold < 60 then
        settings.afkDetection.threshold = settings.afkDetection.threshold + 1
        drawSettingsCP()
      end
    end
  end
end

function toggleShuffle(o, color)
  if Player[color].host or Player[color].promoted then
    settings.playerShuffle = not settings.playerShuffle
    drawSettingsCP()
  end
end

function toggleAnalytics(o, color)
  if not analyticsLocked and Player[color].host == true then
    analytics.optOut = not analytics.optOut
    drawAnalyticsCP()
  end
end


function toggleQueue(o, color)
  if Player[color].host or Player[color].promoted then
    settings.codemasterQueue = not settings.codemasterQueue
    if settings.codemasterQueue then
      -- Show the panel
      queueCP.setRotation({0, 270, 0})
      queueCP.setPosition({-8, 0.91, -32})
    else
      -- Hide the panel
      queueCP.setPosition({-8, -0.5, -32})
      queueCP.setRotation({0, 90, 180})
    end
    drawSettingsCP()
  end
end

function afkCheckLoop()
  if settings.afkDetection.enabled then
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local players = Player.getPlayers()
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((settings.afkDetection.threshold * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end
end

function toggleAFK(o, color)
  if Player[color].host or Player[color].promoted then
    settings.afkDetection.enabled = not settings.afkDetection.enabled
    Wait.stop(afkWaitID)
    if settings.afkDetection.enabled then
      afkWaitID = Wait.time(afkCheckLoop, 1, -1)
    end
    drawSettingsCP()
  end
end

function cluemasterEncode(object, playerColor, input, selected)
  if (playerColor == "Blue" and object.guid == blueEncoding.guid) or (playerColor == "Red" and object.guid == redEncoding.guid) then
    -- Handle encoding
    if string.match(input, "\n") and selected then
      -- Make sure that it's the current codemaster's turn
      if (playerColor == "Blue" and turnTracker == 0) or (playerColor == "Red" and turnTracker == 1) then
        Player[playerColor].broadcast("It's not your turn to enter a clue.", redColor)
        return ""
      end

      local processedClue = processClue(input)
      if processedClue != nil then
        local clue, number = getClueDetails(processedClue)
        if clue != nil and number != nil then
          if number != "inf" and tonumber(number) > 9 then
            Player[playerColor].broadcast("Clues cannot be for more than 9 words.", redColor)
            return ""
          elseif string.len(clue) > 20 then
            Player[playerColor].broadcast("Clues cannot be longer than 20 characters.", redColor)
            return ""
          else
            -- Disable for now until I get Google TTS working
            --playClue(playerColor, clue, number)
            if number == "inf" then
              number = "∞"
              guessesLeft = -1
            elseif number == "0" then
              guessesLeft = -1
            else
              guessesLeft = tostring(number) + 1
            end
            encodeClue(playerColor, clue .. " - " .. number)
            Wait.time(function() drawEncodeInput(object) end, 0.25)
            if not analytics.optOut then
              local payload =
              {
                a = "c",
                g = tostring(analytics.g),
                c = tostring(clue),
                n = tostring(number == "∞" and -1 or number),
                cm = tostring(Player[playerColor].steam_id)
              }
              WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "nullCallback")
            end
            return ""
          end
        else
          Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
          return ""
        end
      else
        Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
        return ""
      end
    end
  else
    -- Player does not have permission
    local team = ""
    if object.guid == redEncoding.guid then
      team = "red"
    elseif object.guid == blueEncoding.guid then
      team = "blue"
    end

    if selected then
      if team != "" then
        Player[playerColor].broadcast("You don't have permission to make clues for the " .. team .. " team!", redColor)
      else
        -- Generic error message
        Player[playerColor].broadcast("You don't have permission to make clues here!", redColor)
      end
      return ""
    end
  end
end

function playClue(team, clue, number)
  local message
  if number == "inf" then
    message = "The " .. team .. " team's code is, " .. clue .. ", with infinite guesses."
  elseif number == "0" then
    message = "The " .. team .. " team's code is to avoid, " .. clue .. ", with infinite guesses."
  else
    message = "The " .. team .. " team's code is, " .. clue .. ", for " .. number
    if number == "1" then
      message = message .. " word."
    else
      message = message .. " words."
    end
  end
  if not analytics.optOut then
    local payload = {
      msg = message,
      voice = "Chris",
      engine = "1"
    }
    WebRequest.post("https://www.lumenvox.com/products/tts/processTTS.ashx", payload, self, "playClueCallback")
  end
end

function playClueCallback(returnData)
  if returnData.is_done then
    local mediaFile = string.match(returnData.text, "^.+<path>(.+)</path>.+$")
    if mediaFile != nil then
      -- Ensure that the returned media file was able to be found in the return XML
      clueTablet.setValue("https://ryan6578.com/tabletopsimulator/codenames/codenames.php?tts=" .. mediaFile)
    end
  end
end

function processClue(clue)
  if type(clue) ~= "string" or clue == "" then
    -- Clue is empty
    return nil
  end
  -- Remove newlines
  clue = clue:gsub("\n", " ")
  -- Trim whitespace
  clue = clue:match( "^%s*(.-)%s*$" )
  -- No errors occured - return the formatted clue
  return clue:lower()
end

function getClueDetails(processedClue)
  -- How many hyphens are there?
  local clue, number
  local _, hyphenCount = string.gsub(processedClue, "%-", "")
  local _, spaceCount = string.gsub(processedClue, "%s", "")

  if hyphenCount == 0 then
    -- Single word with space (or no space) as delimiter
    if spaceCount > 1 then
      return nil, nil
    end

    local checks = {
      "^(%a+)(%s*)(%d+)$",
      "^(%a+)(%s+)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 1 then
    -- Either a hypenated word with a space (or no space) as delimiter
    -- or a single word with a hyphen (and possibly spaces) as delimiter
    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*)(%d+)$",
      "^(%a+%-%a+)(%s+)(inf)$",
      "^(%a+)(%s*%-%s*)(%d+)$",
      "^(%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 2 then

    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*%-%s*)(%d+)$",
      "^(%a+%-%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  else
    -- Clue has too many hyphens
    return nil, nil
  end
end

function rotateclues()
  local objectsInZone = clueZone.getObjects()
  for i, object in ipairs(objectsInZone) do
    local tag = object.tag
    if tag =="Card" then
      object.setRotation({0, 180, 0})
    end
  end
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local clueColor
  local broadcastTo
  if color == "Red" then
    clueColor = redColor
    finishedClue = redToken.clone({
      position     = redToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if redCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (redCluesTracker - 1) do
        if redClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = redClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        redCluesTracker = 0
        redClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            redCluesTracker = redCluesTracker + 1
          end
        end
      end
    end

    -- Set the red clue position
    redClues[redCluesTracker] = finishedClue
    cluePosition = {-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))}
    redCluesTracker = redCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Orange", "Yellow", "Pink", "Brown"}
  elseif color == "Blue" then
    clueColor = blueColor
    finishedClue = blueToken.clone({
      position     = blueToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if blueCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (blueCluesTracker - 1) do
        if blueClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = blueClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        blueCluesTracker = 0
        blueClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            blueCluesTracker = blueCluesTracker + 1
          end
        end
      end
    end

    -- Set the blue clue position
    blueClues[blueCluesTracker] = finishedClue
    cluePosition = {20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))}
    blueCluesTracker = blueCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Teal", "Purple", "Green", "White"}
  end

  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition(cluePosition)
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.setLuaScript(([[
function onload()
  self.createButton({
    label='%s',
    click_function='nullFunction',
    function_owner=self,
    position={0, 0.2, 0},
    height=0,
    width=0,
    font_size=500,
    rotation={0,0,0},
    scale={2, 2, 4/3},
    font_color={1,1,1}
  })
end

function nullFunction() end
]]):format(clue))
  printToAll(color .. " team's clue is: " .. clue, clueColor)
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("Your clue is: " .. clue, clueColor)
  end
end

function toggleTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.timer.enabled = not settings.timer.enabled
    if settings.timer.enabled then
      startTime()
      printToAll("Timer Enabled", {1,1,1})
    else
      if gameStarted then
        clockTimer.setValue(0)
      end
      printToAll("Timer Disabled", {1,1,1})
    end
    drawSettingsCP()
  end
end

function deleteclues()
  -- Delete red clues
  for _, redClue in pairs(redClues) do
    if redClue != nil then
      redClue.destruct()
    end
  end
  redClues = {}
  redCluesTracker = 0

  -- Delete blue clues
  for _, blueClue in pairs(blueClues) do
    if blueClue != nil then
      blueClue.destruct()
    end
  end
  blueClues = {}
  blueCluesTracker = 0
end

function onPlayerConnect(player)
  if not analytics.optOut then
    local disclaimerParam = {}
    disclaimerParam.player = player
    Wait.time(function()
        if player ~= nil then
            player.print(chatDisclaimer, {1, 1, 1})
        end
    end, 10)
  end
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team ="Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team ="None"
    end
  end

  -- Change keymap color if necessary
  local zoneColor = keymapZone.getValue()
  if color == "Blue" and zoneColor != "Blue" then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif color == "Red" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  -- Tell players which team they are on
  if color =="Red" or color =="Orange" or color =="Yellow" or color =="Pink" or color =="Brown" then
    Player[color].broadcast("You are team RED.", {0.856, 0.1, 0.094})
    --announceTeam(color)
  elseif color == "Blue" or color =="Teal" or color =="Purple" or color =="Green" or color =="White" then
    Player[color].broadcast("You are team BLUE.", {0.118, 0.53, 1})
    --announceTeam("Blue", color)
  end
end

function announceTeam(color)
  -- Stop the UI element from showing - buggy
  --[[local attributes = {
    active = false,
    visibility = color
  }
  UI.setAttributes(color .. "Announce", attributes)

  if announceTracker[color] != nil then
    UI.hide(color .. "Announce")
    Timer.destroy(announceTracker[color])
  end]]
  UI.setAttribute(color .. "Welcome", "active", "false")
  local id = color .. "Welcome"
  Wait.time(function() announceStart(id) end, 1)
end

function announceStart(id)
  print("Announce started")
  UI.show(id)
  --UI.setAttribute(id, "active", "true")
  Wait.time(function() announceEnd(id) end, 5)
end

function announceEnd(id)
  print("Announce ended")
  UI.hide(id)
  --UI.setAttribute(id, "active", "false")
end

function startTime()
  if settings.timer.enabled and gameStarted then
    if firstTurn then
      clockTimer.setValue(settings.timer.initial * 60)
    else
      clockTimer.setValue(settings.timer.subsequent * 60)
    end
    clockTimer.Clock.pauseStart()
  end
end

-- Deck fetching
function fetchDeck(deck)
  -- Clear any decks currently in the zone
  clearDeckZone(deckZone)

  local chosenDeck = decks[deck]

  -- Hybrid loading - load a new deck if one doesn't exist
  if chosenDeck.tag == "Infinite" then
    local spawnedDeck = chosenDeck.takeObject({
      position  = {-9.72, -2, 17.99},
      rotation  = {0, 180, 180},
      smooth    = false
    })
    spawnedDeck.setLock(true)
    spawnedDeck.interactable = false
    -- Delete the infinite bag as we no longer need it
    chosenDeck.destruct()
    chosenDeck = spawnedDeck
    decks[deck] = spawnedDeck
  end

  if chosenDeck != nil then
    local deck = chosenDeck.clone({
      position     = {-9.72, 3, 17.99},
      snap_to_grid = true
    })
    deck.setLock(false)
  end
end

-- Clear decks from dealer zone
function clearDeckZone(deckZone)
  for _, object in ipairs(deckZone.getObjects()) do
    if object.tag =="Deck" then
      object.destruct()
    end
  end
end

-- Call functions get deck + clear deckZone
function resetVanilla(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(1)
  end
end

function resetHanii(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(2)
  end
end

function resetCHRY(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(3)
  end
end

function resetUndercover(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(4)
  end
end

function resetSaydi(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(5)
  end
end

function resetMayor(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    fetchDeck(6)
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function newGame(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if newGameStarting == false then
      newGameStarting = true
      local deckFound = findDeck()
      if deckFound then
        reset_agentLocations()
        deleteclues()
        if not analyticsLocked then
          analyticsLocked = true
          -- Destroy the analytics CP - we no longer need it
          analyticsCP.destruct()
        end
        if not analytics.optOut then
          local payload =
          {
            a = "s",
            h = tostring(analytics.h),
            d = tostring(analytics.d)
          }
          WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "setG")
        end
      else
        newGameStarting = false
        Player[color].broadcast("You need to choose a deck before starting.", redColor)
      end
    else
      Player[color].broadcast("A new game is already starting. Please wait.", redColor)
    end
  end
end

function setG(g)
  if g.is_done then
    analytics.g = g.text
  end
end

function nullCallback(null)
end

-- Find deck on top of deck dealer
function findDeck()
    local deckObjects = deckZone.getObjects()
    local toolPos = deckDealer.getPosition()
    local toolPosX = toolPos.x
    local toolPosZ = toolPos.z

    for i, v in pairs(deckObjects) do
        if v.tag == "Deck" then
            local vPos = v.getPosition()
            local vPosX = vPos.x
            local vPosZ = vPos.z
            local dX = toolPosX - vPosX
            local dZ = toolPosZ - vPosZ
            if dX<1 and dX>-1 and dZ<1 and dZ>-1 then
              clearZone(zoneToClear)
              analytics.d = v.getName()
              -- Shuffle players
              if settings.playerShuffle then
                cardsToDeal = v
                startLuaCoroutine(queueCP, "startShuffle")
              elseif settings.codemasterQueue then
                cardsToDeal = v
                startLuaCoroutine(queueCP, "swapCodemasters")
              else
                dealCards(v)
                reset_keymap()
              end
              return true
            end
        end
    end
    return false
end

function isQueueEnabled()
  return codemasterQueue
end

function startGame()
  dealCards(cardsToDeal)
  reset_keymap()
end

-- Deals out cards from deck dealer
function dealCards(deck)
      deck.shuffle()
      local draw_parameters = {}
      draw_parameters.rotation = {0, 180, 0}
      draw_parameters.flip = true
      draw_parameters.top = true

      for i, pos in ipairs(codeLocations) do
          draw_parameters.position = pos
          local c = deck.takeObject(draw_parameters)
          cardsInPlayArea[i] = c
          local cPos = c.getPosition()
          c.setLuaScript([[
          function onLoad()]]
            .. "local timeSet =" .. os.time()
            .. "position = {"
            .. pos.x .. ", "
            .. pos.y .. ", "
            .. pos.z ..
            [[}
            rotation = {0, 180, 0}
            if os.time() - timeSet > 5 then
              self.setPosition(position)
              self.setRotation(rotation)
            end
          end

          function onCollisionEnter(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
              if e != 'Surface' then
                self.setPosition(position)
                self.setRotation(rotation)
              end
            end
          end

          function onCollisionStay(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
              if e != 'Surface' then
                self.setPosition(position)
                self.setRotation(rotation)
              end
            end
          end

          function onCollisionExit(collision_info)
            local res, e = pcall(getObject, collision_info)
            if res == false then
              self.setPosition(position)
              self.setRotation(rotation)
            else
                if e != 'Surface' then
                  self.setPosition(position)
                  self.setRotation(rotation)
                end
            end
          end

          function getObject(info)
            return info.collision_object.tag
          end
          ]])
    end
end

-- Zone clearing
function clearZone(zoneToClear)
  for _, object in ipairs(zoneToClear.getObjects()) do
    if object.tag =="Card" then
      object.destruct()
    end
  end
end

function does_table_have_key( passed_table, passed_key )
-- checks for something in the keys (NOT the values) of a table
    for key,_ in pairs (passed_table) do
        if key == passed_key then
            return true
        end
    end
    return false
end

-- Reset the keymap
function reset_keymap()
  -- Reset game variables
  illegalMove = false
  guessesLeft = -1
  correctTracker = {}
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  local keymap_blue = getObjectFromGUID('65241e')
  local keymap_red = getObjectFromGUID('2ae07d')
  local keymaps = { keymap_blue, keymap_red }

  -- blue goes first = 1, red = 2
  first_random = math.random(2)

  -- put unused keymaps away under the table
  keymap_blue.lock()
  keymap_blue.setRotation( { 0, 0, 0 } )
  keymap_blue.setPosition( { 4, -0.1, 32.4 } )
  keymap_red.lock()
  keymap_red.setRotation( { 0, 0, 0 } )
  keymap_red.setPosition( { -4, -0.1, 32.4 } )

  -- put the keymap corresponding to the first turn team into position
  keymaps[first_random].setRotation( { 0, 0, 0 } )
  keymaps[first_random].setPosition( { 0, 1, -8.4 } )


  local keytile_GUIDs = { 'c7714b', 'c9ec6d', 'edd6a9', '67bb78', '53ea7a', '05e6cf', '03914a', 'e9fbf9', '50a4b1', '181f86', '94bac7', 'c68ce5', '40ca87', 'ad6ced', '29164d', '707d2b', 'e24dad', 'b64b2f', '77f492', '1ee4bf', '5b8638', 'a90289', 'a54e5b', 'd417b5', '6cb9ba' }

  local keytileColors = {
    -- Red keytiles
    ['ad6ced'] = 'red',
    ['c68ce5'] = 'red',
    ['e24dad'] = 'red',
    ['40ca87'] = 'red',
    ['181f86'] = 'red',
    ['94bac7'] = 'red',
    ['29164d'] = 'red',
    ['707d2b'] = 'red',

    -- Blue keytiles
    ['05e6cf'] = 'blue',
    ['edd6a9'] = 'blue',
    ['03914a'] = 'blue',
    ['67bb78'] = 'blue',
    ['53ea7a'] = 'blue',
    ['c9ec6d'] = 'blue',
    ['e9fbf9'] = 'blue',
    ['50a4b1'] = 'blue',

    -- White keytiles
    ['a54e5b'] = 'white',
    ['1ee4bf'] = 'white',
    ['b64b2f'] = 'white',
    ['d417b5'] = 'white',
    ['5b8638'] = 'white',
    ['a90289'] = 'white',
    ['77f492'] = 'white',

    -- Black keytile
    ['c7714b'] = 'black'

    -- Red/Blue keytile
    --['6cb9ba'] = 'redblue'
  }

  -- tile positions on grid are
  -- ~ x = { -2, -1, 0, 1, 2 }
  -- ~ y = 1.23689770698547
  -- ~ z = { -6.4, -7.4, -8.4, -9.4, -10.4 }
  local x_base = -2
  local x_step = 1
  local z_base = -6.4
  local z_step = 1
  local random_list = shuffle_table({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25})
  local index = 0
  for pos, _ in pairs(keymap) do
      local current_keytile = getObjectFromGUID(keytile_GUIDs[random_list[index+1]])
      local x = x_base  +  x_step * (index%5)
      local y = 1.23689770698547
      local z = z_base  -  z_step * math.floor(index/5)
      if current_keytile.guid == "6cb9ba" then
        -- This is the red/blue keytile set based on calculated first_random
        if first_random == 1 then
          -- Blue goes first
          keymap[pos] = 'blue'
          turnTracker = 1
        else
          -- Value is 2 and red goes first
          keymap[pos] = 'red'
          turnTracker = 0
        end
      else
        keymap[pos] = keytileColors[current_keytile.guid]
      end
      current_keytile.lock()
      current_keytile.setRotation( {0,0,0} )
      current_keytile.setPosition( {x,y,z} )
      index = index + 1
  end

  -- flip the extra tile blue side if blue goes first
  if first_random == 1 then
      local double_tile = getObjectFromGUID('6cb9ba')
      double_tile.setRotation( {0, 0, 180 } )
      -- move it upwards by its own depth because flipping changes position
      local double_tile_position = double_tile.getPosition()
      double_tile.setPosition({double_tile_position.x, double_tile_position.y+0.1, double_tile_position.z })
  end
  setDoubleTimer()
end

function shuffle_table( passed_table )
-- fisher-yates shuffle

    for current_index = #passed_table, 1, -1 do
        local swap_index = math.random(#passed_table)
        passed_table[current_index], passed_table[swap_index] = passed_table[swap_index], passed_table[current_index]
    end
    return passed_table

end

function setDoubleTimer()
  Wait.time(setDouble, 1)
end

function setDouble()
  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  if first_random == 1 then
    -- Set the correct double card to blue
    doubleBlue.setLock(false)
    doubleBlue.setPosition(agentLocations[doubleBlue.guid])
    doubleBlue.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  elseif first_random == 2 then
    -- Set the correct double card to red
    doubleRed.setLock(false)
    doubleRed.setPosition(agentLocations[doubleRed.guid])
    doubleRed.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(redRot)
    buttonTeams.setPosition(redPos)
    printToAll("Red team's turn.", redColor)
  end

  -- Change the gameStarted to 1
  gameStarted = true

  -- Start the timer
  firstTurn = true
  startTime()

  -- Game has successfully started
  newGameStarting = false
end

function reset_agentLocations()
  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  -- resets the agent cards to their start positions
  for guid, pos in pairs(agentLocations) do
    local card = getObjectFromGUID(guid)
    if card then
      if card.guid == doubleRed.guid then
        doubleRed.interactable = false
        doubleRed.setLock(true)
        doubleRed.setPosition({0, -2, -14})
      elseif card.guid == doubleBlue.guid then
        doubleBlue.interactable = false
        doubleBlue.setLock(true)
        doubleBlue.setPosition({0, -2, -14})
      else
        card.setPosition(pos)
        card.setRotation({0,180,180})
        card.unlock()
        card.interactable = true
      end
    end
  end
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if agentLocations[agent.guid] == nil then
    return
  end

  local codeObjects = clueZone.getObjects()
  local agentPos = agent.getPosition()
  local searchThreshold = 1
  for _, code in pairs(codeObjects) do
    local codePos = code.getPosition()
    local dX = math.abs(agentPos.x - codePos.x)
    local dZ = math.abs(agentPos.z - codePos.z)
    if code.guid != agent.guid and code.tag == "Card" and dX<searchThreshold and dZ<searchThreshold then
      -- Orient cards properly
      code.setRotationSmooth({0, 180, 0})
      agent.setRotationSmooth({0, 180, 180})

      -- Check to see if the agent card was placed correctly, but only if placed by blue or red
      if color == "Red" or color == "Blue" then
        --If illegal condition is set, dont allow for any more placing
        if illegalMove then
          agent.setPositionSmooth(agentTracker[agent.guid])
          return
        end

        local roundedPos = {x = round(codePos.x, 2), z = round(codePos.z, 2)}
        local codeColor = checkLocation(roundedPos)
        local agentColor = agentColors[agent.guid]

        if codeColor == agentColor then
          -- Card was placed correctly
          if correctTracker[roundedPos.x .. roundedPos.z] == nil then
            correctTracker[roundedPos.x .. roundedPos.z] = agent.guid
            code.interactable = false
            agent.interactable = false
            local lockParam = {}
            lockParam.agent = agent
            lockParam.code = code
            Wait.time(function lockCorrect(lockParam) end, 1)
            -- Check to see if one team has won
            local redWon = true
            local blueWon = true

            for guid, agtColor in pairs(agentColors) do
              if agtColor == "red" then
                if first_random == 1 and guid == "3ef1ca" then
                  -- Red double agent not in use
                elseif getObjectFromGUID(guid).interactable then
                  redWon = false
                end
              elseif agtColor == "blue" then
                if first_random == 2 and guid == "1e9282" then
                  -- Blue double agent not in use
                elseif getObjectFromGUID(guid).interactable then
                  blueWon = false
                end
              end

              -- Skip unnecessary iterations
              if redWon == false and blueWon == false then
                break
              end
            end
            -- Four scenarios:
            -- 1) white - done
            -- 2) opposite color - done
            -- 3) Black
            -- 4) Correct
            -- If card is white, or card is of the opposite color, then toggle toggleTurns
            -- 0 = RED; 1 = BLUE
            guessesLeft = guessesLeft - 1
            if codeColor == "black" or blueWon or redWon then
              -- End game scenario
              if (codeColor == "black" and turnTracker == 0) or blueWon then
                -- Red placed black card, blue wins
                -- or blue placed all of their cards
                broadcastToAll("Blue team wins!", blueColor)
              elseif (codeColor == "black" and turnTracker == 1) or redWon then
                -- Blue placed black card, red wins
                -- or red placed all of their cards
                broadcastToAll("Red team wins!", redColor)
              end

              -- Set the game back to initial state
              gameStarted = false

              -- Set the timer to 0 and disable
              clockTimer.setValue(0)

              -- Move the remaining agents to their codes
              endGame()
              if not analytics.optOut then
                local payload =
                {
                  a = "e",
                  g = tostring(analytics.g)
                }
                WebRequest.post("https://ryan6578.com/codenames/analytics.php", payload, self, "nullCallback")
              end
            elseif guessesLeft == 0 or codeColor == "white" or (codeColor == "red" and turnTracker == 1) or (codeColor == "blue" and turnTracker == 0) then
              toggleTurns()
            end
          else
            agent.setPositionSmooth(agentTracker[agent.guid])
            Player[color].broadcast("This code has already been marked correctly.", redColor)
          end
        else
          -- Card was placed incorrectly
          illegalMove = true
        end
      else
        -- Move the placed card back to its original position
        agent.setPositionSmooth(agentTracker[agent.guid])
        Player[color].broadcast("Only codemasters are able to place agent cards.", redColor)
      end
    end
  end
end

function lockCorrect(params)
  local agent = params.agent
  local code = params.code
  agent.setLock(true)
  code.setLock(true)

  -- Ensure the tile is on the code
  agent.setPosition(code.getPosition())
  agent.setRotation({0, 180, 180})


  local ensureParam = {}
  ensureParam.agent = agent
  ensureParam.position = code.getPosition()

  Wait.time(function ensurePos(ensureParam) end, 1)
end

function ensurePos(params)
  local agent = params.agent
  agent.setPosition(params.position)
  agent.setRotation({0, 180, 180})
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" then
    local clues = clueZone.getObjects()
    local position = object.getPosition()
    for i, v in pairs(clues) do
      if v.guid == object.guid and v.tag == "Card" then
        -- Prevent picking up of codes
        for _, card in ipairs(cardsInPlayArea) do
          if card.guid == object.guid then
            object.reload()
            break
          end
        end
      end
    end
  elseif object.tag == "Tile" and agentLocations[object.guid] != nil then
    -- Track the original locations of the tiles
    local tileZoneObj = tileZone.getObjects()
    for _, obj in pairs(tileZoneObj) do
      if obj.guid == object.guid then
        agentTracker[object.guid] = object.getPosition()
      end
    end

    -- Prevent picking up of agent tiles from anyone but red or blue
    if color != "Blue" and color != "Red" then
      for guid,_ in pairs(agentLocations) do
        if guid == object.guid then
          --object.reload()
        end
      end
    end
  end

  -- Agent dealCards
  if illegalMove and object.tag == "Tile" and agentColors[object.guid] != nil then
    -- Only check entire board if an error condition exists
    local boardIsCorrect = true
    local placedTiles = clueZone.getObjects()
    for _, v in pairs(placedTiles) do
      if v.guid != object.guid and v.tag == "Tile" and agentLocations[v.guid] != nil then
        local agtPos = v.getPosition();
        if checkLocation({x = agtPos.x, z = agtPos.z}) != agentColors[v.guid] then
          boardIsCorrect = false;
        end
      end
    end
    if boardIsCorrect then
      illegalMove = false
    end
  end
end

function endGame()

  local codesLeft = {}

  local blueAgentsLeft = {}
  local blueNum = 1
  local redAgentsLeft = {}
  local redNum = 1
  local whiteAgentsLeft = {}
  local whiteNum = 1
  local blackAgentsLeft = {}

  local numCodes = 0

  -- Get the remining codes left
  for i, pos in ipairs(codeLocations) do
    if correctTracker[pos.x .. pos.z] == nil then
      codesLeft[#codesLeft+1] = pos
      numCodes = numCodes + 1
    end
  end

  -- Get the remaining agent cards
  for guid, agtColor in pairs(agentColors) do
    if agtColor == "red" then
      if first_random == 1 and guid == "3ef1ca" then
        -- Red double agent not in use
      elseif getObjectFromGUID(guid).interactable then
        redAgentsLeft[#redAgentsLeft+1] = guid
      end
    elseif agtColor == "blue" then
      if first_random == 2 and guid == "1e9282" then
        -- Blue double agent not in use
      elseif getObjectFromGUID(guid).interactable then
        blueAgentsLeft[#blueAgentsLeft+1] = guid
      end
    elseif agtColor == "white" and getObjectFromGUID(guid).interactable then
      whiteAgentsLeft[#whiteAgentsLeft+1] = guid
    elseif agtColor == "black" and getObjectFromGUID(guid).interactable then
      blackAgentsLeft[#blackAgentsLeft+1] = guid
    end
  end

  local timeDelay = 0

  for _, pos in ipairs(codesLeft) do
    local posColor = checkLocation(pos)

    if posColor == "red" then
      agent = getObjectFromGUID(redAgentsLeft[redNum])
      redNum = redNum + 1
    elseif posColor == "blue" then
      agent = getObjectFromGUID(blueAgentsLeft[blueNum])
      blueNum = blueNum + 1
    elseif posColor == "white" then
      agent = getObjectFromGUID(whiteAgentsLeft[whiteNum])
      whiteNum = whiteNum + 1
    elseif posColor == "black" then
      agent = getObjectFromGUID(blackAgentsLeft[1])
    end

    local clues = clueZone.getObjects()
    local object = agent
    local cardX = pos.x
    local cardZ = pos.z
    local searchThreshold = 0.90
    for i, v in pairs(clues) do
      local vPos = v.getPosition()
      local vPosX = vPos.x
      local vPosZ = vPos.z
      local dX = cardX - vPosX
      local dZ = cardZ - vPosZ
      if v.guid != agent.guid and v.tag == "Card" and dX<searchThreshold and dX>-searchThreshold and dZ<searchThreshold and dZ>-searchThreshold then
        -- Orient cards properly
        local endParam = {}
        endParam.id = math.random()
        endParam.agent = agent
        endParam.code = v
        endParam.pos = pos
        Wait.time(function() endCardSet(endParam) end, timeDelay)
      end
    end
    timeDelay = timeDelay + 0.15
  end
end

function endCardSet(endParam)
  local code = endParam.code
  local agent = endParam.agent
  local pos = endParam.pos

  code.interactable = false;
  agent.interactable = false;
  code.setLock(true)
  code.setRotationSmooth({0, 180, 0})
  agent.setRotation({0, 180, 180})
  agent.setPositionSmooth(pos)
  agent.setLock(true)
end

function onUpdate()
  -- Check for clock rundown if timer is enabled
  if settings.timer.enabled and newGameStarting == false and gameStarted and illegalMove == false then
    local timerVal = clockTimer.getValue()
    if timerVal == 0 then
      -- Switch turns
      timerWarning = timerVal
      broadcastToAll("Time's up!", redColor)
      toggleTurns()
    elseif timerVal == 60 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll("1 minute remaining!", redColor)
    elseif timerVal <= 5 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll(timerVal .. " seconds remaining!", redColor)
    end
  end

  -- Notify codemasters of illegal move
  if illegalMove then
    if updateTimer == 100 then
      Player["Blue"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      Player["Red"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      updateTimer = 0
    else
      updateTimer = updateTimer + 1
    end
  end
end

function checkLocation(position)
  for pos,color in pairs(keymap) do
    if pos == (tostring(round(position.x, 2)) .. "," .. tostring(round(position.z, 2))) then
      return color
    end
  end
end

function round(exact, precision)
   return math.floor(exact*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function toggleTurns()
  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  firstTurn = false

  -- Reset the guesses each team has left
  guessesLeft = -1

  if turnTracker == 0 then
    -- Red team's turn ends, switch to blue team
    turnTracker = 1
    buttonRed.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  else
    -- Blue team's turn ends, switch to red team
    turnTracker = 0
    buttonBlu.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  rotateclues()

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    if illegalMove == false then
      -- Is it the current side's turn?
      if turnTracker == 0 and button.guid == buttonBlu.guid or turnTracker == 1 and button.guid == buttonRed.guid then
        --Player[color].print("It's not your turn!")
        return
      end

      -- Reset the timer warning
      timerWarning = -1

      -- Make sure it isn't the first turn
      firstTurn = false

      -- Reset the guesses each team has left
      guessesLeft = -1

      if turnTracker == 0 then
        -- Red team's turn ends, switch to blue team
        turnTracker = 1
        buttonRed.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(blueRot)
        buttonTeams.setPositionSmooth(bluePos)
        printToAll("Blue team's turn.", blueColor)
      else
        -- Blue team's turn ends, switch to red team
        turnTracker = 0
        buttonBlu.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(redRot)
        buttonTeams.setPositionSmooth(redPos)
        printToAll("Red team's turn.", redColor)
      end

      rotateclues()

      startTime()

    else
      -- Notify the person trying to end the turn that there are cards incorrectly placed on the board
      Player[color].broadcast("Please fix the incorrectly placed agent cards before ending your turn.", redColor)
    end
  end
end
