--[[

  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2020  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

]]

chatDisclaimer =
[[

                  [da1918]ANALYTICS DISCLAIMER[-]
[-]This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. By continuing, you
acknowledge and accept this in accordance
with the privacy policy outlined below.

More info:
[8bb5ff]https://ryan6578.com/codenames/stats/privacy[-]

Statistics:
[8bb5ff]https://ryan6578.com/codenames/stats[-]

]]

redColor = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}

-- Red team plaque position and rotation
redPos = {-20.7, 0.91, 17.94}
redRot = {0, 180, 0}

-- Blue team plaque position and rotation
bluePos = {20.7, 0.91, 17.94}
blueRot = {0, 180, 180}

-- Color = Blue/Red/Black/White
cards =
{
  -- Row 1 (cards 1-5)
  {position = {x = -11.4, z = 12.6}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 12.6}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 12.6}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 12.6}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 12.6}, guid = nil, value = nil, color = nil, covered = false},

  -- Row 2 (cards 6-10)
  {position = {x = -11.4, z = 8.75}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 8.75}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 8.75}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 8.75}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 8.75}, guid = nil, value = nil, color = nil, covered = false},

  -- Row 3 (cards 11-15)
  {position = {x = -11.4, z =  4.9}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z =  4.9}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z =  4.9}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z =  4.9}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z =  4.9}, guid = nil, value = nil, color = nil, covered = false},

  -- Row 4 (cards 16-20)
  {position = {x = -11.4, z = 1.05}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 1.05}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 1.05}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 1.05}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 1.05}, guid = nil, value = nil, color = nil, covered = false},

  -- Row 5 (cards 21-25)
  {position = {x = -11.4, z = -2.8}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = -2.8}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = -2.8}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = -2.8}, guid = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = -2.8}, guid = nil, value = nil, color = nil, covered = false}
}

agents =
{
  -- Assassain
  ['b97df2'] = {position = {x = 0.04, y = 2, z = -17.84 }, color = "Black", enabled = true},

  -- Blue agents
  ['1e9282'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Blue", enabled = false},
  ['7fdaee'] = {position = {x = 12.34, y = 2, z = -13.97 }, color = "Blue", enabled = true},
  ['99832c'] = {position = {x = 18.07, y = 2, z = -13.97 }, color = "Blue", enabled = true},
  ['d9324a'] = {position = {x = 23.77, y = 2, z = -13.97 }, color = "Blue", enabled = true},
  ['19b2d5'] = {position = {x = 29.47, y = 2, z = -13.97 }, color = "Blue", enabled = true},
  ['0f0ec0'] = {position = {x = 12.34, y = 2, z = -17.8  }, color = "Blue", enabled = true},
  ['d9054c'] = {position = {x = 18.07, y = 2, z = -17.8  }, color = "Blue", enabled = true},
  ['4de840'] = {position = {x = 23.77, y = 2, z = -17.8  }, color = "Blue", enabled = true},
  ['05c73d'] = {position = {x = 29.47, y = 2, z = -17.8  }, color = "Blue", enabled = true},

  -- Red agents
  ['3ef1ca'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Red", enabled = false},
  ['746660'] = {position = {x = -12.22, y = 2, z = -13.97 }, color = "Red", enabled = true},
  ['9cbe84'] = {position = {x = -17.92, y = 2, z = -13.97 }, color = "Red", enabled = true},
  ['6bb4d8'] = {position = {x = -23.62, y = 2, z = -13.97 }, color = "Red", enabled = true},
  ['b48ed4'] = {position = {x = -29.32, y = 2, z = -13.97 }, color = "Red", enabled = true},
  ['5c1be6'] = {position = {x = -12.22, y = 2, z = -17.8  }, color = "Red", enabled = true},
  ['b89ba7'] = {position = {x = -17.92, y = 2, z = -17.8  }, color = "Red", enabled = true},
  ['e1754e'] = {position = {x = -23.62, y = 2, z = -17.8  }, color = "Red", enabled = true},
  ['4a2969'] = {position = {x = -29.32, y = 2, z = -17.8  }, color = "Red", enabled = true},

  -- Civialians
  ['f6786b'] = {position = {x = -5.7, y = 2, z = -21.7 }, color = "White", enabled = true},
  ['e44594'] = {position = {x = -5.7, y = 2, z = -17.84 }, color = "White", enabled = true},
  ['1f53f2'] = {position = {x = -5.7, y = 2, z = -14 }, color = "White", enabled = true},
  ['f8f6a1'] = {position = {x = 0.04, y = 2, z = -21.7 }, color = "White", enabled = true},
  ['a05e4e'] = {position = {x = 5.74, y = 2, z = -21.7 }, color = "White", enabled = true},
  ['1ebedd'] = {position = {x = 5.74, y = 2, z = -17.84 }, color = "White", enabled = true},
  ['3d7b86'] = {position = {x = 5.74, y = 2, z = -14 }, color = "White", enabled = true}
}

votes =
{
  [0] =
  {
    ["Orange"]  = {
      card = 0
    },
    ["Yellow"]  = {
      card = 0
    },
    ["Pink"]    = {
      card = 0
    },
    ["Brown"]   = {
      card = 0
    }
  },
  [1] =
  {
    ["Teal"]    = {
      card = 0
    },
    ["Purple"]  = {
      card = 0
    },
    ["Green"]   = {
      card = 0
    },
    ["White"]   = {
      card = 0
    }
  }
}

----------[ Game state ]----------
gameState =
{
  -- Tracks whether the current game has started (-1 = not started, 0 = starting, 1 = started)
  status = -1,

  -- Current game is on the first turn or not
  firstTurn = false,

  -- Tracks whose turn it currently is
  turnTracker = 1,

  -- Tracks how many guesses the team has left
  guessesLeft = -1,

  -- Tracks if the current team is able to vote
  canVote = false,

  -- Red clue tracker
  redClues = {},

  -- Blue clue tracker
  blueClues = {},

  -- Tracks the players to ignore for color switching
  playersToIgnore = {}
}

----------[ Game settings ]----------
settings =
{
  -- Shuffle players at start
  playerShuffle = true,

  -- Enable codemaster queue
  codemasterQueue = true,

  -- Quick color switcher buttons
  colorSwitcher = true,

  -- Disable/Enable "inf meta"
  cardTilting = false,

  -- Show shooting star background
  starBackground = true,

  -- Show table lighting
  tableLighting = true,

  -- AFK detection
  afkDetection =
  {
    enabled   = false,
    threshold = 10
  },

  -- Timer enabled
  timer =
  {
    enabled     = true,
    initial     = 8,
    subsequent  = 4
  },

  -- Automod functions
  automod =
  {
    autokick = true
  }
}

----------[ Game analytics ]----------
analytics =
{
  url = "https://ryan6578.com:8080/api/",
  gameID = "",
  host = "",
  deck = "",
  clueID = nil,
  players = {}
}

function onload(saveState)

  -- Codenames script version
  version = "2.1.0"

  ----------[ Script object initialization ]----------
  -- Control panels and table objects
  tableObject     = getObjectFromGUID("246b85")

  -- Game objects
  deckDealer      = getObjectFromGUID("27d226")
  buttonTeams     = getObjectFromGUID("8a85e8")
  redToken        = getObjectFromGUID("f3cdf2")
  blueToken       = getObjectFromGUID("3f75b3")
  clockTimer      = getObjectFromGUID("0b1336")
  buttonRed       = getObjectFromGUID("f16a9a")
  buttonBlu       = getObjectFromGUID("c91f34")

  -- Decks
  deckVanilla     = getObjectFromGUID("83b607")
  deckHanii       = getObjectFromGUID("92bb6b")
  deckCHRY        = getObjectFromGUID("41f57c")
  deckUndercover  = getObjectFromGUID("ee8afd")
  deckSaydi       = getObjectFromGUID("d75160")
  deckMayor       = getObjectFromGUID("3a3e8c")

  -- Lights
  spaceParticles  = getObjectFromGUID("8430cf")
  ambient_bot     = getObjectFromGUID("6fb111")
  ambient_top     = getObjectFromGUID("05032c")
  teams_red       = getObjectFromGUID("a1b2cd")
  teams_blue      = getObjectFromGUID("6072b1")

  -- Zones
  deckZone        = getObjectFromGUID("33d9ff")

  ----------[ Interactable objects ]----------
  -- Control panels and table objects
  tableObject.interactable    = false

  -- Game objects
  deckDealer.interactable     = false
  buttonTeams.interactable    = false
  redToken.interactable       = false
  blueToken.interactable      = false

  -- Decks
  deckVanilla.interactable    = false
  deckHanii.interactable      = false
  deckCHRY.interactable       = false
  deckUndercover.interactable = false
  deckSaydi.interactable      = false
  deckMayor.interactable      = false

  -- Lights
  spaceParticles.interactable = false
  ambient_bot.interactable    = false
  ambient_top.interactable    = false
  teams_red.interactable      = false
  teams_blue.interactable     = false

  decks = {
    -- Vanilla
    [1] = deckVanilla,

    -- Hanii
    [2] = deckHanii,

    -- CHRY
    [3] = deckCHRY,

    -- Undercover
    [4] = deckUndercover,

    -- Saydi's
    [5] = deckSaydi,

    -- Mayor's
    [6] = deckMayor
  }

  buttonBlu.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    Wait.frames(function()
      player.lookAt({
        position = {0, 0, 0},
        pitch    = 60,
        yaw      = 0,
        distance = 45
      })
    end, 1)
  end

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    if decodedSaveState.version == version and decodedSaveState.gameState.status == 1 then
      -- Load the previous gameState
      gameState = decodedSaveState.gameState

      -- Load the previous settings and update the view
      settings = decodedSaveState.settings
      tableObject.call("updateSettings")

      -- Load the analytics data
      analytics = decodedSaveState.analytics

      -- Load the card data and update their UI
      cards = decodedSaveState.cards
      for cardNum, cardData in ipairs(cards) do
        attachCardUI(getObjectFromGUID(cardData.guid), cardNum)
      end

      -- Update the enabled property for agents
      for agentGUID, agentData in pairs(decodedSaveState.agents) do
        if agents[agentGUID] ~= nil then
          agents[agentGUID].enabled = agentData.enabled
        end
      end
    end
  end

  for _, player in ipairs(Player.getPlayers()) do
    if player.host then
      analytics.host = player.steam_id
      break
    end
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function onSave()
  local saveData = {}

  saveData.version    = version
  saveData.gameState  = gameState
  saveData.settings   = settings
  saveData.analytics  = analytics
  saveData.cards      = cards
  saveData.agents     = agents

  return JSON.encode(saveData)
end

------------------------------------------------------------------------
--------------------[ SETTERS/GETTERS FOR SETTINGS ]--------------------
------------------------------------------------------------------------

function setShuffle(enabled) settings.playerShuffle = enabled end
function getShuffle() return settings.playerShuffle end

function setQueue(enabled) settings.codemasterQueue = enabled end
function getQueue() return settings.codemasterQueue end

function setSwitcher(enabled) settings.colorSwitcher = enabled end
function getSwitcher() return settings.colorSwitcher end

function setTilting(enabled)
  settings.cardTilting = enabled
  -- Disable card tilting
  if gameState.status == 1 and not gameState.canVote then
    for _, card in ipairs(cards) do
      if not card.covered then
        local cardObject = getObjectFromGUID(card.guid)
        if cardObject ~= nil then
          cardObject.setLock(enabled)
          cardObject.setRotationSmooth({0, 180, 0})
        end
      end
    end
  end
end
function getTilting() return settings.cardTilting end

function setStars(enabled)
  settings.starBackground = enabled
  -- Enable/Disable star background
  spaceParticles.AssetBundle.playLoopingEffect(enabled and 0 or 1)
end
function getStars() return settings.starBackground end

function setLighting(enabled)
  settings.tableLighting = enabled
  -- Enable/Disable table lighting
  ambient_bot.setPositionSmooth({x = 0, y = enabled and 4.35 or 0, z = -26}, false, false)
  ambient_top.setPositionSmooth({x = 0, y = enabled and 4.35 or 0, z = 26}, false, false)
  teams_red.setPositionSmooth({x = -44, y = enabled and 4.35 or 0, z = 0}, false, false)
  teams_blue.setPositionSmooth({x = 44, y = enabled and 4.35 or 0, z = 0}, false, false)
end
function getLighting() return settings.tableLighting end

function setAfk(enabled)
  settings.afkDetection.enabled = enabled
  Timer.destroy("afkLoop")
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function setTimer(enabled)
  settings.timer.enabled = enabled
  if settings.timer.enabled then
    startTime()
  else
    if gameState.status == 1 then
      clockTimer.setValue(0)
    end
  end
end
function getTimer() return settings.timer.enabled end

function setTimer1Time(value) settings.timer.initial = value end
function getTimer1Time() return settings.timer.initial end

function setTimer2Time(value) settings.timer.subsequent = value end
function getTimer2Time() return settings.timer.subsequent end

function setAutokick(enabled) settings.automod.autokick = enabled end
function getAutokick() return settings.automod.autokick end

function afkCheckLoop()
  if settings.afkDetection.enabled then
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((settings.afkDetection.threshold * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end
end

function clueEntered(player, value)
  if value:match("\n") then
    local color = player.color

    -- Reset the text box
    local resetInput = {
      text          = "",
      placeholder   = "Enter clue here"
    }
    UI.setAttributes(color:lower() .. "ClueText", resetInput)

    -- if the game hasn't been started, a clue cannot be entered
    if gameState.status ~= 1 then
      Player[color].broadcast("You must start a game to enter a clue.", redColor)
      return
    end

    -- Make sure that it's the current codemaster's turn
    if (color == "Blue" and gameState.turnTracker == 0) or (color == "Red" and gameState.turnTracker == 1) then
      Player[color].broadcast("It's not your turn to enter a clue.", redColor)
      return
    end

    -- Remove the newline, trim the clue, and convert to lowercase
    value = value:gsub("\n", ""):match("%s*(.-)%s*$"):lower()

    -- Parse the entered clue into its respective parts
    local clue, number, error = getClueDetails(value)

    -- Handle clue parsing errors
    if error then
      -- Clue wasn't able to be parsed - general error
      Player[color].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
      return
    elseif number != "inf" and tonumber(number) > 9 then
      -- Clue was larger than 9 words (not 0 or inf)
      Player[color].broadcast("Clues cannot be for more than 9 words.", redColor)
      return
    elseif string.len(clue) > 20 then
      -- Clue was larger than 20 characters
      Player[color].broadcast("Clues cannot be longer than 20 characters.", redColor)
      return
    end

    -- Don't allow a clue that isn't covered
    for cardIndex, cardData in ipairs(cards) do
      if not cardData.covered and cardData.value:lower() == clue:lower() then
        Player[color].broadcast("Invalid clue. That word has not been covered yet, so it may not be used!", redColor)
        return
      end
    end

    -- Track remaining clues
    if number == "inf" then
      gameState.guessesLeft = -1
    elseif number == "0" then
      gameState.guessesLeft = -1
    else
      gameState.guessesLeft = tostring(number) + 1
    end

    -- Encode the finished clue
    encodeClue(color, clue .. " - " .. number:gsub("inf", "âˆž"))

    -- Enable voting for the current team
    gameState.canVote = true

    -- Disable card tilting
    if settings.cardTilting then
      for _, card in ipairs(cards) do
        if not card.covered then
          local cardObject = getObjectFromGUID(card.guid)
          cardObject.setLock(false)
          cardObject.setRotationSmooth({0, 180, 0})
        end
      end
    end

    -- Send analytics data for the a new clue
    analytics_clueNew(clue, number == "inf" and -1 or number, Player[color].steam_id)
  end
end

function getClueDetails(processedClue)
  -- How many hyphens are there?
  local clue, number
  local _, hyphenCount = string.gsub(processedClue, "%-", "")
  local _, spaceCount = string.gsub(processedClue, "%s", "")

  if hyphenCount == 0 then
    -- Single word with space (or no space) as delimiter
    if spaceCount > 1 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+)(%s*)(%d+)$",
      "^(%a+)(%s+)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  elseif hyphenCount == 1 then
    -- Either a hypenated word with a space (or no space) as delimiter
    -- or a single word with a hyphen (and possibly spaces) as delimiter
    if spaceCount > 2 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+%-%a+)(%s*)(%d+)$",
      "^(%a+%-%a+)(%s+)(inf)$",
      "^(%a+)(%s*%-%s*)(%d+)$",
      "^(%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  elseif hyphenCount == 2 then

    if spaceCount > 2 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+%-%a+)(%s*%-%s*)(%d+)$",
      "^(%a+%-%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  else
    -- Clue has too many hyphens
    return nil, nil, true
  end
end

function rotateclues()
  for cardIndex, cardData in ipairs(cards) do
    local card = getObjectFromGUID(cardData.guid)
    if card.interactable then
      card.setRotation({0, 180, 0})
    end
  end
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local token = color == "Red" and redToken or blueToken
  local broadcastTo = color == "Red" and {"Orange", "Yellow", "Pink", "Brown"} or {"Teal", "Purple", "Green", "White"}

  local clues = color == "Red" and gameState.redClues or gameState.blueClues
  local xPos = color == "Red" and -21.05 or 20.85
  local deletedClues = false
  local validClues = {}

  -- Check for deleted clues and shift the remaining if need be
  if #clues > 0 then
    -- Check for deleted clues
    for _,clue in ipairs(color == "Red" and gameState.redClues or gameState.blueClues) do
      if getObjectFromGUID(clue) ~= nil then
        table.insert(validClues, clue)
      else
        deletedClues = true
      end
    end
  end

  if deletedClues then
    if color == "Red" then
      gameState.redClues = validClues
    else
      gameState.blueClues = validClues
    end
    for i, clue in ipairs(validClues) do
      local clueObject = getObjectFromGUID(clue)
      clueObject.setPosition({xPos, 1.5, (12 - (((i - 1) % 8) * 2.05))})
      clueObject.setRotation({0, 180, 0})
    end
  end
  local finishedClue = token.clone({
    position     = token.getPosition(),
    snap_to_grid = true,
    callback_function = function(clue) table.insert(color == "Red" and gameState.redClues or gameState.blueClues, clue.guid) end
  })
  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition({xPos, 1.5, (12 - ((#(color == "Red" and gameState.redClues or gameState.blueClues) % 8) * 2.05))})
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.setLuaScript(
    "function onload()\n"
      .. "self.createButton({\n"
        .. "label='" .. clue .. "', click_function='nullFunction', function_owner=self,\n"
        .. "position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}\n"
      .. "})\n"
    .. "end\n"
  )
  printToAll(color .. " team's clue is: " .. clue, color)
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("Your clue is: " .. clue, color)
  end
end

function deleteClues()
  -- Delete red clues
  for _, redClue in pairs(gameState.redClues) do
    if redClue != nil then
      local clue = getObjectFromGUID(redClue)
      if clue ~= nil then
        clue.destruct()
      end
    end
  end
  redClues = {}

  -- Delete blue clues
  for _, blueClue in pairs(gameState.blueClues) do
    if blueClue != nil then
      local clue = getObjectFromGUID(blueClue)
      if clue ~= nil then
        clue.destruct()
      end
    end
  end
  blueClues = {}
end

function onPlayerConnect(player)
  -- Send analytics disclaimer
  player.print(chatDisclaimer, {1, 1, 1})

  -- Check the blacklist for the player
  WebRequest.get(analytics.url .. "player/blacklisted/" .. player.steam_id, function(responseRaw)
    if responseRaw.is_done then
      local response = JSON.decode(responseRaw.text)

      if response.dateAdded ~= nil then
        if settings.automod.autokick then
          player.kick()
        end
        printToAll("\n", {1, 1, 1})
        printToAll(player.steam_name .. " was found in the global Codenames blacklist!", redColor)
        printToAll("SteamID     : " .. player.steam_id, redColor)
        printToAll("Date Added  : " .. response.dateAdded, redColor)
        printToAll("Reason      : " .. response.reason, redColor)
        printToAll("\n", {1, 1, 1})
      end
    end
  end)
end

function onPlayerDisconnect(player)
  -- Destroy the timer for the disclaimer, if one exists
  Timer.destroy(player.steam_id)

  -- End session with player if one exists
  if gameState.status == 1 then
    if analytics.players[player.steam_id] ~= nil then
      analytics_sessionEnd({player.steam_id})
    end
  end
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Reset the player's vote (if necessary)
  if gameState.status == 1 then
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
      if not Player[playerColor].seated and voteData.card ~= 0 then
        local card = voteData.card
        voteData.card = 0
        updateVoteUI(card)
      end
    end
  end

  local endSession = {}

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team = "Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if analytics.players[spec.steam_id] ~= nil then
        table.insert(endSession, spec.steam_id)
      end
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team = "None"
    end
  end

  if color ~= "Grey" and color ~= "Black" then
    announceTeam(color)

    if gameState.status == 1 and analytics.players[Player[color].steam_id] == nil then
      analytics_sessionStart({Player[color].steam_id})
    end
  elseif gameState.status == 1 and (color == "Grey" or color == "Black") and #endSession ~= 0 then
    analytics_sessionEnd(endSession)
  end
end

function announceTeam(color)
  Wait.frames(
    function()
      if Player[color].seated == false then
        return
      end
      UI.show(color .. 'Announce')
      Wait.frames(
        function()
          if Player[color].seated == false then
            UI.setAttribute(color .. 'Announce', 'active', 'false')
            return
          end
          UI.hide(color .. 'Announce')
        end, 100
      )
    end, 50
  )
end

function startTime()
  if settings.timer.enabled then
    if gameState.firstTurn then
      clockTimer.setValue(settings.timer.initial * 60)
    else
      clockTimer.setValue(settings.timer.subsequent * 60)
    end
    clockTimer.Clock.pauseStart()
  end
end

-- Deck fetching
function fetchDeck(deck)
  -- Clear any decks currently in the zone
  clearDeckZone(deckZone)

  local chosenDeck = decks[deck]

  -- Hybrid loading - load a new deck if one doesn't exist
  if chosenDeck.tag == "Infinite" then
    chosenDeck.takeObject({
      position          = {-9.72, -2, 17.99},
      rotation          = {0, 180, 180},
      smooth            = false,
      callback_function = function(spawnedDeck)
                            spawnedDeck.setLock(true)
                            spawnedDeck.interactable = false
                            -- Delete the infinite bag as we no longer need it
                            --chosenDeck.destruct()
                            chosenDeck = spawnedDeck
                            decks[deck] = spawnedDeck

                            chosenDeck.clone({
                              position     = {-9.72, 3, 17.99},
                              snap_to_grid = true,
                              callback_function = function(deck) deck.setLock(false) end
                            })
                          end
    })
  else
    local deck = chosenDeck.clone({
      position     = {-9.72, 3, 17.99},
      snap_to_grid = true
    })
    deck.setLock(false)
  end
end

-- Clear decks from dealer zone
function clearDeckZone(deckZone)
  for _, object in ipairs(deckZone.getObjects()) do
    if object.tag =="Deck" then
      object.destruct()
    end
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function newGame(player)
  -- Check to see whether a new game is currently being set up
  local oldStatus = gameState.status
  if gameState.status == 0 then
    player.broadcast("A new game is already starting. Please wait.", redColor)
    return
  end

  -- A new game is currently starting - block any other new game requests
  gameState.status = 0

  -- Find the deck currently in use
  currentDeck = findDeck()

  if currentDeck == nil then
    -- Deck was not able to be found
    gameState.status = oldStatus
    player.broadcast("You need to choose a deck before starting.", redColor)
    return
  end

  -- Reset the game to its original state
  resetGame()

  if settings.playerShuffle then
    --tableObject.call("shufflePlayers")
    startLuaCoroutine(tableObject, "shufflePlayers")
  elseif settings.codemasterQueue then
    --tableObject.call("swapCodemasters")
    startLuaCoroutine(tableObject, "swapCodemasters")
  else
    startGame()
  end

  --[[Wait.frames(function()
    startGame()
  end, 120)]]
end

function resetGame()
  -- Reset cards
  for i = 1, 25, 1 do
    -- Delete the instance of the card
    if cards[i].guid ~= nil then
      getObjectFromGUID(cards[i].guid).destruct()
    end

    -- Remove all card data
    cards[i].guid = nil
    cards[i].color = nil
    cards[i].covered = false
  end

  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  -- resets the agent cards to their start positions
  for guid, agentData in pairs(agents) do
    local card = getObjectFromGUID(guid)
    if card then
      if card.guid == doubleRed.guid then
        doubleRed.interactable = false
        doubleRed.setLock(true)
        doubleRed.setPositionSmooth({0, -2, -14})
        agents[card.guid].enabled = false
      elseif card.guid == doubleBlue.guid then
        doubleBlue.interactable = false
        doubleBlue.setLock(true)
        doubleBlue.setPositionSmooth({0, -2, -14})
        agents[card.guid].enabled = false
      else
        card.setPosition(agentData.position)
        card.setRotation({0,180,180})
        card.unlock()
        card.interactable = true
      end
    end
  end

  deleteClues()

  -- Reset game variables
  gameState.guessesLeft = -1
end

-- Find deck on top of deck dealer
function findDeck()
    local deckObjects = deckZone.getObjects()
    local toolPos = deckDealer.getPosition()

    for i, v in pairs(deckObjects) do
        if v.tag == "Deck" then
            local vPos = v.getPosition()
            local dX = toolPos.x - vPos.x
            local dZ = toolPos.z - vPos.z
            if dX<1 and dX>-1 and dZ<1 and dZ>-1 then
              -- Suitable deck found
              analytics.deck = v.getName()
              return v
            end
        end
    end

    -- No deck was found
    return nil
end

function startGame()
  -- Determine which team should go first (0 = RED; 1 = BLUE)
  gameState.turnTracker = math.random(2) - 1

  -- Shuffle the keymap
  local bank = {"Red", "Red", "Red" ,"Red", "Red", "Red", "Red", "Red", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "White", "White", "White", "White", "White", "White", "White", "Black"}
  if gameState.turnTracker == 0 then
    -- Add another red
    bank = table.insert(bank, "Red")
  else
    -- Add another blue
    bank = table.insert(bank, "Blue")
  end

  for i = 1, 25, 1 do
    cards[i].color = table.remove(bank, math.random(1, #bank))
  end

  -- Choose the correct double agent card for which team goes first
  local doubleBlue = getObjectFromGUID('1e9282')
  local doubleRed = getObjectFromGUID("3ef1ca")

  if gameState.turnTracker == 0 then
    -- Set the correct double card to red
    doubleRed.setLock(false)
    doubleRed.setPositionSmooth(agents[doubleRed.guid].position)
    doubleRed.interactable = true
    agents[doubleRed.guid].enabled = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  elseif gameState.turnTracker == 1 then
    -- Set the correct double card to blue
    doubleBlue.setLock(false)
    doubleBlue.setPositionSmooth(agents[doubleBlue.guid].position)
    doubleBlue.interactable = true
    agents[doubleBlue.guid].enabled = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  end

  dealCards(currentDeck)

  -- Start the timer
  gameState.firstTurn = true

  -- Send analytics data for the start of a game
  analytics_gameStart()
end

-- Deals out cards from deck dealer
function dealCards(deck)
  deck.shuffle()
  for i = 1, 25, 1 do
    local c = deck.takeObject({
      rotation            = {0, 180, 0},
      flip                = true,
      top                 = true,
      position            = {cards[i].position.x, 1.03, cards[i].position.z},
      callback_function   = function(card) attachCardUI(card, i) end
    })
  end
end

function attachCardUI(card, i)
  local bounds = card.getBounds()
  local sizeX = math.floor(bounds.size.x * 75)
  local sizeZ = math.floor(bounds.size.z * 75)
  cards[i].value = card.getName()
  if cards[i].color == "Black" then
    card.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
      rectAlignment="MiddleCenter"
      color="%s"
      width="%s"
      height="%s"
      outline="#e7e52c"
      outlineSize="4 -5"
      ></Panel>
      <Panel id="vote-1" active="false" scale="0.5 1" position="69 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-2" active="false" scale="0.5 1" position="23 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-3" active="false" scale="0.5 1" position="-23 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-4" active="false" scale="0.5 1" position="-69 -75 -100" width="75" height="75" color="Black"></Panel>]], cards[i].color, sizeZ, sizeX))
  else
    card.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
      rectAlignment="MiddleCenter"
      color="%s"
      width="%s"
      height="%s"
      ></Panel>
      <Panel id="vote-1" active="false" scale="0.5 1" position="69 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-2" active="false" scale="0.5 1" position="23 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-3" active="false" scale="0.5 1" position="-23 -75 -100" width="75" height="75" color="Black"></Panel>
      <Panel id="vote-4" active="false" scale="0.5 1" position="-69 -75 -100" width="75" height="75" color="Black"></Panel>]], cards[i].color, sizeZ, sizeX))
  end

  card.setLuaScript(string.format([[
    position = {%s, 1.03, %s}
    rotation = {0, 180, 0}

    function onCollisionEnter(collision_info)
      if collision_info == nil or collision_info.collision_object.tag != 'Surface' then
        self.setLock(true)
        self.setPosition(position)
        self.setRotation(rotation)
        Wait.frames(function()
          self.setPosition(position)
          self.setRotation(rotation)
          if self.interactable then
            self.setLock(false)
          end
        end, 10)
      end
    end
    ]], cards[i].position.x, cards[i].position.z))

  cards[i].guid = card.guid

  -- Once the last card has loaded in, allow a new game to be started
  if i == 25 then
    -- Disable card tilting
    if settings.cardTilting then
      for _, card in ipairs(cards) do
        if not card.covered then
          local cardObject = getObjectFromGUID(card.guid)
          cardObject.setLock(true)
          cardObject.setRotationSmooth({0, 180, 0})
        end
      end
    end
    startTime()
    gameState.status = 1
  end
end

function findClosestCard(threshold, position)
  local closestCard =
  {
    index = nil,
    distance = nil
  }

  for cardIndex,_ in ipairs(cards) do
    local dX = position.x - cards[cardIndex].position.x
    local dZ = position.z - cards[cardIndex].position.z

    local d = math.sqrt((dX^2) + (dZ^2))

    if d < threshold then
      if closestCard.index == nil or d < closestCard.distance then
        closestCard.index = cardIndex
        closestCard.distance = d
      end
    end
  end

  return closestCard.index
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if gameState.status ~= 1 or agent.tag ~= "Tile" or agents[agent.guid] == nil then
    return
  end

  -- Find the closest card position to the dropped agent
  local cardIndex = findClosestCard(1.65, agent.getPosition())
  if cardIndex == nil or cards[cardIndex].covered then
    -- Either no close card found, or card is already covered
    return
  end

  -- Check to see if the agent and the card are the same color
  local agentColor = agents[agent.guid].color
  local cardColor = cards[cardIndex].color
  if cardColor ~= agentColor then
    agent.setPositionSmooth(agents[agent.guid].position)
    Player[color].broadcast("An agent has been placed incorrectly. You placed a " .. agentColor .. " agent on a " .. cardColor .. " card.", redColor)
    return
  end

  -- Card has been marked correctly
  gameState.guessesLeft = gameState.guessesLeft - 1
  cards[cardIndex].covered = true

  coverCard(cardIndex, agent.guid)

  -- Send analytics data for the guess
  local players = ""
  local correct = ((gameState.turnTracker == 0 and cardColor == "Red") or (gameState.turnTracker == 1 and cardColor == "Blue")) and "TRUE" or "FALSE"
  for color,_ in pairs(votes[gameState.turnTracker]) do
    if Player[color].seated then
      players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
    end
  end
  analytics_clueGuess(players, tostring(cards[cardIndex].value), correct, cardColor:upper())

  -- Check to see if either red or blue won
  local redWon = true
  local blueWon = true
  for i = 1, 25, 1 do
    if cards[i].color == "Red" and not cards[i].covered then
      redWon = false
    elseif cards[i].color == "Blue" and not cards[i].covered then
      blueWon = false
    end

    if not redWon and not blueWon then
      -- Skip unnecessary iterations
      break
    end
  end

  if agentColor == "Black" or blueWon or redWon then
    -- End game scenario

    -- Analytics data for end of game
    if (agentColor == "Black" and gameState.turnTracker == 0) or blueWon then
      -- Red placed black card, blue wins
      -- or blue placed all of their cards
      broadcastToAll("Blue team wins!", blueColor)
      analytics_gameEnd("BLUE")
    elseif (agentColor == "Black" and gameState.turnTracker == 1) or redWon then
      -- Blue placed black card, red wins
      -- or red placed all of their cards
      broadcastToAll("Red team wins!", redColor)
      analytics_gameEnd("RED")
    end

    -- Move the remaining agents to their codes
    endGame()
  elseif gameState.guessesLeft == 0 or agentColor == "White" or (agentColor == "Red" and gameState.turnTracker == 1) or (agentColor == "Blue" and gameState.turnTracker == 0) then
    toggleTurns()
  else
    -- Show the pass turn button and change color
    tableObject.UI.setAttributes("passTurn", {
      color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
      active = true
    })
  end
end

function playerVote(color, card)
  -- Update the player's vote
  if color == "Grey" then
    -- Ignore votes from spectators
    return
  end

  if color == "Red" or color == "Blue" or color == "Black" then
    Player[color].broadcast('You cannot vote!', redColor)
    return
  elseif votes[gameState.turnTracker][color] == nil then
    Player[color].broadcast('It\'s not your turn to vote!', redColor)
    return
  elseif not gameState.canVote then
    Player[color].broadcast('You can\'t vote until you\'ve been given a clue!', redColor)
    return
  end

  if votes[gameState.turnTracker][color].card == 0 then
    votes[gameState.turnTracker][color].card = card
    updateVoteUI(card)
  else
    if votes[gameState.turnTracker][color].card == card then
      -- Remove this player's vote
      votes[gameState.turnTracker][color].card = 0
      updateVoteUI(card)
    else
      -- Switch the player's current vote to this card
      local previous = votes[gameState.turnTracker][color].card
      votes[gameState.turnTracker][color].card = card
      updateVoteUI(previous)
      updateVoteUI(card)
    end
  end

  -- Check to see if a vote has passed
  local votePassed = false
  local voteCard = nil
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if Player[playerColor].seated and not Player[playerColor].blindfolded then
      if (voteCard == nil and voteData.card ~= 0) or voteData.card == voteCard then
        votePassed = true
        voteCard = voteData.card
      else
        votePassed = false
        break
      end
    end
  end

  if votePassed then
    -- Vote passed to pass turn
    if card == 26 then
      toggleTurns()
      return
    end

    -- Clear the votes
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
      votes[gameState.turnTracker][playerColor].card = 0
    end

    -- Card has been marked correctly
    gameState.guessesLeft = gameState.guessesLeft - 1
    cards[card].covered = true

    -- Cover the card
    coverCard(card, nil)

    -- Send analytics data for the guess
    local players = ""
    local correct = ((gameState.turnTracker == 0 and cards[card].color == "Red") or (gameState.turnTracker == 1 and cards[card].color == "Blue")) and "TRUE" or "FALSE"
    for color,_ in pairs(votes[gameState.turnTracker]) do
      if Player[color].seated then
        players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
      end
    end
    analytics_clueGuess(players, tostring(cards[card].value), correct, cards[card].color:upper())

    -- Check to see if either red or blue won
    local redWon = true
    local blueWon = true
    for i = 1, 25, 1 do
      if cards[i].color == "Red" and not cards[i].covered then
        redWon = false
      elseif cards[i].color == "Blue" and not cards[i].covered then
        blueWon = false
      end

      if not redWon and not blueWon then
        -- Skip unnecessary iterations
        break
      end
    end

    if cards[card].color == "Black" or blueWon or redWon then
      -- End game scenario

      if (cards[card].color == "Black" and gameState.turnTracker == 0) or blueWon then
        -- Red placed black card, blue wins
        -- or blue placed all of their cards
        broadcastToAll("Blue team wins!", blueColor)
        analytics_gameEnd("BLUE")
      elseif (cards[card].color == "Black" and gameState.turnTracker == 1) or redWon then
        -- Blue placed black card, red wins
        -- or red placed all of their cards
        broadcastToAll("Red team wins!", redColor)
        analytics_gameEnd("RED")
      end

      -- Move the remaining agents to their codes
      endGame()

    elseif gameState.guessesLeft == 0 or cards[card].color == "White" or (cards[card].color == "Red" and gameState.turnTracker == 1) or (cards[card].color == "Blue" and gameState.turnTracker == 0) then
      toggleTurns()
    else
      -- Show the pass turn button and change color
      tableObject.UI.setAttributes("passTurn", {
        color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
        active = true
      })
    end
  end
end

function coverCard(cardIndex, agentGUID)
  local cardObject = getObjectFromGUID(cards[cardIndex].guid)
  for guid, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(guid)
    if agents[guid].enabled and agentData.color == cards[cardIndex].color and agentObject.interactable and (agentGUID == nil or agentGUID == guid) then
      local position = {cards[cardIndex].position.x, 1.03, cards[cardIndex].position.z}

      -- Remove the UI from the card
      cardObject.UI.setXml("")

      -- Remove the script from the card
      --cardObject.setLuaScript("")

      -- Lock both cards and set them in place
      cardObject.interactable = false
      agentObject.interactable = false

      cardObject.setLock(true)
      agentObject.setLock(true)

      -- Ensure the tile is on the code
      cardObject.setRotationSmooth({0, 180, 0})
      agentObject.setRotationSmooth({0, 180, 180})

      cardObject.setPositionSmooth(position)
      agentObject.setPositionSmooth(position)
      break
    end
  end
end

function updateVoteUI(card)
  local uiObject = nil
  local uiID = nil

  if card == 26 then
    -- Vote to pass
    uiObject = tableObject
    uiID = "pass-"
  else
    -- Vote for a card
    uiObject = getObjectFromGUID(cards[card].guid)
    uiID = "vote-"
  end

  local votesToAdd = {}
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if voteData.card == card then
      votesToAdd[playerColor] = true
    end
  end
  local votesOnCard =
  {
    uiObject.UI.getAttribute(uiID .. "1", "color"),
    uiObject.UI.getAttribute(uiID .. "2", "color"),
    uiObject.UI.getAttribute(uiID .. "3", "color"),
    uiObject.UI.getAttribute(uiID .. "4", "color")
  }
  local newVotes = {}

  -- Keep the order of the current votes
  for voteIndex, voteColor in ipairs(votesOnCard) do
    if voteColor ~= "Black" then
      if votes[gameState.turnTracker][voteColor].card == card then
        table.insert(newVotes, voteColor)
        votesToAdd[voteColor] = nil
      end
    else
      -- Add the uncounted votes
      for playerColor,_ in pairs(votesToAdd) do
        table.insert(newVotes, playerColor)
      end
      break
    end
  end

  for i = 1,4,1 do
    if newVotes[i] ~= nil then
      uiObject.UI.setAttributes(uiID .. i, {
        color = newVotes[i],
        active = true
      })
    else
      uiObject.UI.setAttributes(uiID .. i, {
        color = "Black",
        active = false
      })
    end
  end
end

function votePass(color)
  playerVote(color, 26)
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" and not object.spawning then
    for i = 1, 25, 1 do
      if cards[i].guid == object.guid then
        object.setVelocity({0, 0, 0})
        object.drop()
        object.setPosition({cards[i].position.x, 1.03, cards[i].position.z})
        if #Player[color].getSelectedObjects() <= 1 then
          playerVote(color, i)
        end
        break
      end
    end
  elseif agents[object.guid] ~= nil then
    -- Prevent picking up of agent tiles from anyone but red or blue
    if color ~= "Red" and color ~= "Blue" then
      object.setVelocity({0, 0, 0})
      object.drop()
      object.setPosition({agents[object.guid].position.x, 1.01, agents[object.guid].position.z})
    end
  end
end

function endGame()
  -- Disable voting for any teams
  gameState.canVote = false

  -- Set the game back to initial state
  gameState.status = -1

  -- Set the timer to 0 and disable
  clockTimer.setValue(0)

  -- Hide the pass turn button and change color
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Assign remaining agents to uncovered clues
  for i = 1, 25, 1 do
    if not cards[i].covered then
      coverCard(i, nil)
    end
  end
end

function onUpdate()
  -- Check for clock rundown if timer is enabled
  if settings.timer.enabled and gameState.status == 1 then
    local timerVal = clockTimer.getValue()
    if timerVal == 0 then
      -- Switch turns
      timerWarning = timerVal
      broadcastToAll("Time's up!", redColor)
      toggleTurns()
    elseif timerVal == 60 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll("1 minute remaining!", redColor)
    elseif timerVal <= 10 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll(timerVal .. " seconds remaining!", redColor)
    end
  end
end

function round(exact, precision)
   return math.floor(exact*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function toggleTurns()
  -- Diable voting for the current team
  gameState.canVote = false

  -- Disable card tilting
  for _, card in ipairs(cards) do
    if not card.covered then
      local cardObject = getObjectFromGUID(card.guid)
      if settings.cardTilting then
        cardObject.setLock(true)
      end
      cardObject.setRotationSmooth({0, 180, 0})
    end
  end

  local cardsToClear = {}
  -- Remove all vote indicators and reset votes
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    -- Update the vote UI first
    if voteData.card ~= 0 and (voteData.card == 26 or not cards[voteData.card].covered) then
      table.insert(cardsToClear, voteData.card)
    end

    -- Reset that player's vote
    votes[gameState.turnTracker][playerColor].card = 0
  end

  for _, card in ipairs(cardsToClear) do
    updateVoteUI(card)
  end

  -- Hide the pass turn button
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  gameState.firstTurn = false

  -- Reset the guesses each team has left
  gameState.guessesLeft = -1

  -- Reset the clueID
  analytics.clueID = nil

  if gameState.turnTracker == 0 then
    -- Red team's turn ends, switch to blue team
    gameState.turnTracker = 1
    buttonRed.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  else
    -- Blue team's turn ends, switch to red team
    gameState.turnTracker = 0
    buttonBlu.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    -- Is it the current side's turn?
    if gameState.turnTracker == 0 and button.guid == buttonBlu.guid or gameState.turnTracker == 1 and button.guid == buttonRed.guid then
      return
    end

    toggleTurns()

  end
end

function ignoreChanges(request)
  table.insert(gameState.playersToIgnore, request)
end

function shouldUpdateAnalytics(steamID, color)
  for i, request in ipairs(gameState.playersToIgnore) do
    if request.steamID == steamID then
      if request.color == color then
        -- Allow going forward
        table.remove(gameState.playersToIgnore, i)
      end
      return false
    end
  end
  -- Player doesn't have a change request - allow by default
  return true
end

-------------------------------------------------------------------------------
--------------------------------[[ ANALYTICS ]]--------------------------------
-------------------------------------------------------------------------------

function sendAnalytics(api, payload, callback)
  WebRequest.post(analytics.url .. api, payload, callback)
end

function analytics_gameStart()
  local request =
  {
    host    = analytics.host,
    deck    = analytics.deck,
    first   = gameState.turnTracker == 0 and "RED" or "BLUE"
  }

  sendAnalytics("games/start", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

        -- Set the current game ID
        analytics.gameID = response.gameID

        -- Reset the player sessions
        analytics.players = {}

        -- Reset the previous clue ID
        analytics.clueID = nil

        -- Payload string for players
        local players = {}

        -- Repopulate the teams
        for _, player in ipairs(Player.getPlayers()) do
          local color = player.color
          if color ~= "Grey" and color ~= "Black" then
            table.insert(players, player.steam_id)
          end
        end

        -- Start sessions for seated players
        analytics_sessionStart(players)
      end
    end)
end

function analytics_clueNew(clue, number, codemaster)
  local request =
  {
    gameID = analytics.gameID,
    code = tostring(clue),
    number = tostring(number),
    codemaster = tostring(codemaster),
    team = tostring(gameState.turnTracker == 0 and "RED" or "BLUE")
  }

  sendAnalytics("clues/new", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

        analytics.clueID = response.clueID
      end
    end)
end

function analytics_clueGuess(players, guess, correct, color)
  local request =
  {
    clueID = analytics.clueID,
    players = players,
    guess = guess,
    correct = correct,
    color = color
  }

  sendAnalytics("clues/guess", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

      end
    end)
end

function analytics_sessionStart(players)
  local request =
  {
    gameID = analytics.gameID,
    players = ""
  }

  for _, player in ipairs(players) do
    request.players = request.players .. ((request.players == "") and player or (',' .. player))
  end

  sendAnalytics("players/sessions/start", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

        for _, session in ipairs(response.sessions) do
          analytics.players[session.steamID] = session.sessionID
        end
      end
    end)
end

function analytics_sessionEnd(players)
  local request =
  {
    sessions = ""
  }

  for _, player in ipairs(players) do
    request.sessions = request.sessions .. ((request.sessions == "") and analytics.players[player] or (',' .. analytics.players[player]))
  end

  sendAnalytics("players/sessions/end", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

        for _, player in ipairs(players) do
          analytics.players[player] = nil
        end

      end
    end)
end

function analytics_gameEnd(winner)
  local request =
  {
    gameID  = analytics.gameID,
    winner  = winner
  }

  sendAnalytics("games/end", request,
    function(responseRaw)
      if responseRaw.is_done then
        local response = JSON.decode(responseRaw.text)

        if response.status == "error" then
          print("Error received from analytics:")
          print(response.message)
          return
        end

        -- Set the current game ID
        analytics.gameID = nil

        -- Reset the clue ID
        analytics.clueID = nil

        -- Payload string for sessions
        local players = {}

        -- Repopulate the teams
        for steamID, sessionID in pairs(analytics.players) do
          table.insert(players, steamID)
        end

        -- End all sessions for seated players
        analytics_sessionEnd(players)
      end
    end)
end