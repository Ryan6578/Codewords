--[[
  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2021  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
]]

chatDisclaimer =
[[

                  [da1918]ANALYTICS DISCLAIMER[-]
[-]This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. By continuing, you
acknowledge and accept this in accordance
with the privacy policy outlined below.

More info:
[8bb5ff]https://tts-codenames.com/privacy[-]

]]

redColor  = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}

-- Color = Blue/Red/Black/White
cards = {
  -- Row 1 (cards 1-5)
  {position = {x = -11.4, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 2 (cards 6-10)
  {position = {x = -11.4, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 3 (cards 11-15)
  {position = {x = -11.4, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 4 (cards 16-20)
  {position = {x = -11.4, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 5 (cards 21-25)
  {position = {x = -11.4, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false}
}

agents = {
  -- Assassain
  ['b97df2'] = {position = {x = 0.04, y = 2, z = -17.84 }, color = "Black", covering = nil, enabled = true},

  -- Blue agents
  ['1e9282'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Blue", covering = nil, enabled = false},
  ['7fdaee'] = {position = {x = 12.34, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['99832c'] = {position = {x = 18.07, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['d9324a'] = {position = {x = 23.77, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['19b2d5'] = {position = {x = 29.47, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['0f0ec0'] = {position = {x = 12.34, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['d9054c'] = {position = {x = 18.07, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['4de840'] = {position = {x = 23.77, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['05c73d'] = {position = {x = 29.47, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},

  -- Red agents
  ['3ef1ca'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Red", covering = nil, enabled = false},
  ['746660'] = {position = {x = -12.22, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['9cbe84'] = {position = {x = -17.92, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['6bb4d8'] = {position = {x = -23.62, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['b48ed4'] = {position = {x = -29.32, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['5c1be6'] = {position = {x = -12.22, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['b89ba7'] = {position = {x = -17.92, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['e1754e'] = {position = {x = -23.62, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['4a2969'] = {position = {x = -29.32, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},

  -- Civialians
  ['1f53f2'] = {position = {x = -5.7, y = 2, z = -14 }, color = "White", covering = nil, enabled = true},
  ['3d7b86'] = {position = {x = 5.74, y = 2, z = -14 }, color = "White", covering = nil, enabled = true},
  ['e44594'] = {position = {x = -5.7, y = 2, z = -17.84 }, color = "White", covering = nil, enabled = true},
  ['1ebedd'] = {position = {x = 5.74, y = 2, z = -17.84 }, color = "White", covering = nil, enabled = true},
  ['f6786b'] = {position = {x = -5.7, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true},
  ['f8f6a1'] = {position = {x = 0.04, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true},
  ['a05e4e'] = {position = {x = 5.74, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true}
}

votes = {
  [0] = {
    ["Orange"]  = 0,
    ["Yellow"]  = 0,
    ["Pink"]    = 0,
    ["Brown"]   = 0
  },
  [1] = {
    ["Teal"]    = 0,
    ["Purple"]  = 0,
    ["Green"]   = 0,
    ["White"]   = 0
  }
}

----------[ Game state ]----------
gameState =
{
  -- Tracks whether the current game has started (-1 = not started, 0 = starting, 1 = started)
  status = -1,

  -- Current game is on the first turn or not
  firstTurn = true,

  -- Tracks whose turn it currently is
  turnTracker = 1,

  -- Tracks how many guesses the team has left
  guessesLeft = -1,

  -- Tracks if the current team is able to vote
  canVote = false,

  -- Red clue tracker
  redClues = {},

  -- Blue clue tracker
  blueClues = {}
}

----------[ Game settings ]----------
settings =
{
  -- Shuffle players at start
  playerShuffle = true,

  -- Enable codemaster queue
  codemasterQueue = true,

  -- Quick color switcher buttons
  colorSwitcher = true,

  -- Disable/Enable "inf meta"
  cardTilting = false,

  -- Show shooting star background
  starBackground = true,

  -- Show table lighting
  tableLighting = true,

  -- AFK detection
  afkDetection =
  {
    enabled   = false,
    threshold = 10
  },

  -- Timer enabled
  timer =
  {
    enabled     = true,
    initial     = 8,
    subsequent  = 4
  },

  -- Automod functions
  automod =
  {
    autokick = true
  }
}

----------[ Decks ]----------
deck =
{
  -- The currently selected deck(s)
  selected = {},

  -- Whether or not multiple deck mode is enabled
  multiple = false,

  -- The current words for the selected deck
  words = nil,

  -- Total amount of decks available for query
  totalDecks = 0,

  -- Search term
  searchTerm = nil,

  -- Wait id of search delay
  searchDelay = nil,

  -- Current page size
  pageSize = 10,

  -- Current result page
  pageNum = 0,

  -- Tracks deck fetch requests
  fetchingDecks = false
}

----------[ Game analytics ]----------
analytics =
{
  url       = "https://api.tts-codenames.com",
  gameID    = nil,
  host      = nil,
  clueID    = nil,
  sessions  = {}
}

----------[ Character sets ]----------

digits_table = {
[0]={48,1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296},
[1]={49,1633,1777,1985,2407,2535,2663,2791,2919,3047,3175,3303,3431,3559,3665,3793,3873,4161,4241,6113,6161,6471,6609,6785,6801,6993,7089,7233,7249,42529,43217,43265,43473,43505,43601,44017,65297},
[2]={50,1634,1778,1986,2408,2536,2664,2792,2920,3048,3176,3304,3432,3560,3666,3794,3874,4162,4242,6114,6162,6472,6610,6786,6802,6994,7090,7234,7250,42530,43218,43266,43474,43506,43602,44018,65298},
[3]={51,1635,1779,1987,2409,2537,2665,2793,2921,3049,3177,3305,3433,3561,3667,3795,3875,4163,4243,6115,6163,6473,6611,6787,6803,6995,7091,7235,7251,42531,43219,43267,43475,43507,43603,44019,65299},
[4]={52,1636,1780,1988,2410,2538,2666,2794,2922,3050,3178,3306,3434,3562,3668,3796,3876,4164,4244,6116,6164,6474,6612,6788,6804,6996,7092,7236,7252,42532,43220,43268,43476,43508,43604,44020,65300},
[5]={53,1637,1781,1989,2411,2539,2667,2795,2923,3051,3179,3307,3435,3563,3669,3797,3877,4165,4245,6117,6165,6475,6613,6789,6805,6997,7093,7237,7253,42533,43221,43269,43477,43509,43605,44021,65301},
[6]={54,1638,1782,1990,2412,2540,2668,2796,2924,3052,3180,3308,3436,3564,3670,3798,3878,4166,4246,6118,6166,6476,6614,6790,6806,6998,7094,7238,7254,42534,43222,43270,43478,43510,43606,44022,65302},
[7]={55,1639,1783,1991,2413,2541,2669,2797,2925,3053,3181,3309,3437,3565,3671,3799,3879,4167,4247,6119,6167,6477,6615,6791,6807,6999,7095,7239,7255,42535,43223,43271,43479,43511,43607,44023,65303},
[8]={56,1640,1784,1992,2414,2542,2670,2798,2926,3054,3182,3310,3438,3566,3672,3800,3880,4168,4248,6120,6168,6478,6616,6792,6808,7000,7096,7240,7256,42536,43224,43272,43480,43512,43608,44024,65304},
[9]={57,1641,1785,1993,2415,2543,2671,2799,2927,3055,3183,3311,3439,3567,3673,3801,3881,4169,4249,6121,6169,6479,6617,6793,6809,7001,7097,7241,7257,42537,43225,43273,43481,43513,43609,44025,65305}
}

spaceCharacters = {}
for _, code in pairs({32,160,5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8239,8287,12288,65279}) do
  spaceCharacters[code] = true
end

hyphenCharacters = {}
for _, code in pairs({45,8208,8209,8210,8211,8212,8213,11834,11835,65112,65123,65293}) do
  hyphenCharacters[code] = true
end

digitCharacters = {}
for digit, arr in pairs(digits_table) do
  for _, code in pairs(arr) do
    digitCharacters[code] = tostring(digit) -- strings are interpreted as 'true' for boolean expressions, even empty ones
  end
end

whitespaceCharacters = {}
for _, code in pairs({9,10,11,12,13,28,29,30,31,133,8232,8233}) do
  whitespaceCharacters[code] = true
end
for code, _ in pairs(spaceCharacters) do
  whitespaceCharacters[code] = true
end

illegalCharacters   = {}
-- put several character ranges into the illegalCharacters table
local illegalCharacterRanges = 
          {
            {0, 64},    -- before uppercase letters
            {91, 96},   -- before lowercase letters
            {123, 191}, -- before accented letters
            {215, 215}, {247, 247}, -- multiplication and division sign
            {448, 451}, -- symbols
            {688, 767}, -- symbols
          }
for _, range in pairs(illegalCharacterRanges) do
  local code_st, code_end = table.unpack(range)
  for code = code_st, code_end do 
    illegalCharacters[code] = true
  end
end                                                 
-- include hyphens
for code, _ in pairs(hyphenCharacters) do
  illegalCharacters[code] = true
end
-- include whitespace characters
for code, _ in pairs(whitespaceCharacters) do
  illegalCharacters[code] = true
end
-- include digit characters
for code, _ in pairs(digitCharacters) do
  illegalCharacters[code] = true
end

function onload(saveState)

  -- Codenames script version
  version = "3.2.3"

  ----------[ Script object initialization ]----------
  -- Control panels and table objects
  customTable     = getObjectFromGUID("bab013")
  tableObject     = getObjectFromGUID("0a61c6")

  -- Game objects
  cardTemplates   = getObjectFromGUID("2fb333")
  extraBlue       = getObjectFromGUID("1e9282")
  extraRed        = getObjectFromGUID("3ef1ca")
  redToken        = getObjectFromGUID("f3cdf2")
  blueToken       = getObjectFromGUID("3f75b3")
  buttonRed       = getObjectFromGUID("f16a9a")
  buttonBlue      = getObjectFromGUID("c91f34")

  ----------[ Interactable objects ]----------
  -- Control panels and table objects
  customTable.interactable    = false
  tableObject.interactable    = false

  -- Game objects
  cardTemplates.interactable  = false
  extraBlue.interactable      = false
  extraRed.interactable       = false
  redToken.interactable       = false
  blueToken.interactable      = false

  -- Create variable for storing typed clues
  currentEnteredClue = {}

  -- Get the list of decks
  api_getDecks()

  buttonBlue.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- Make agents non-selectable
  for agentGUID, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(agentGUID)
    if agentObject then
      agentObject.drag_selectable = false
    end
  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.print(chatDisclaimer, {1, 1, 1})
    Wait.frames(function()
      player.lookAt({
        position = {0, 0, 0},
        pitch    = 60,
        yaw      = 0,
        distance = 45
      })
    end, 1)
  end

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    -- TODO:
      -- votes
      -- currently selected decks
      -- table ui elements

    if decodedSaveState.version == version and decodedSaveState.gameState.status == 1 then
      -- Load the previous gameState
      gameState = decodedSaveState.gameState

      -- Load the previous settings and update the view
      settings = decodedSaveState.settings
      tableObject.call("updateSettings")

      -- Load the analytics data
      analytics = decodedSaveState.analytics

      -- Load the card data and update their UI
      cards = decodedSaveState.cards
      dealCards()

      -- Update the enabled property for agents
      agents = decodedSaveState.agents
      for agentGUID, agentData in pairs(decodedSaveState.agents) do
        if agents[agentGUID] ~= nil and agents[agentGUID].covering ~= nil then
          coverCard(agents[agentGUID].covering, agentGUID)
        end
      end
    end
  end

  for _, player in ipairs(Player.getPlayers()) do
    if player.host then
      analytics.host = player.steam_id
      break
    end
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function onSave()
  local saveData = {}

  saveData.version    = version
  saveData.gameState  = gameState
  saveData.settings   = settings
  saveData.analytics  = analytics
  saveData.cards      = cards
  saveData.agents     = agents

  return JSON.encode(saveData)
end

------------------------------------------------------------------------
--------------------[ SETTERS/GETTERS FOR SETTINGS ]--------------------
------------------------------------------------------------------------

function setShuffle(enabled) settings.playerShuffle = enabled end
function getShuffle() return settings.playerShuffle end

function setQueue(enabled) settings.codemasterQueue = enabled end
function getQueue() return settings.codemasterQueue end

function setSwitcher(enabled) settings.colorSwitcher = enabled end
function getSwitcher() return settings.colorSwitcher end

function setTilting(enabled)
  settings.cardTilting = enabled
end
function getTilting() return settings.cardTilting end

function setAfk(enabled)
  settings.afkDetection.enabled = enabled
  Timer.destroy("afkLoop")
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function setTimer(enabled)
  settings.timer.enabled = enabled
  if settings.timer.enabled then
    startTime()
  else
    -- Disable the timer
  end
end
function getTimer() return settings.timer.enabled end

function setTimer1Time(value) settings.timer.initial = value end
function getTimer1Time() return settings.timer.initial end

function setTimer2Time(value) settings.timer.subsequent = value end
function getTimer2Time() return settings.timer.subsequent end

function setAutokick(enabled) settings.automod.autokick = enabled end
function getAutokick() return settings.automod.autokick end

function toggleDeckMode() deck.multiple = not deck.multiple end
function getMultipleDeckMode() return deck.multiple end

function afkCheckLoop()
  -- Temporarily removed
  --[[if settings.afkDetection.enabled then
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((settings.afkDetection.threshold * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end]]
end

function previousPage()
  if (deck.pageNum - 1 < 0) or deck.fetchingDecks then
    return
  end

  deck.pageNum = deck.pageNum - 1
  api_getDecks()
end

function nextPage()
  if (deck.pageNum + 1 > math.ceil(deck.totalDecks / deck.pageSize) - 1) or deck.fetchingDecks then
    return
  end

  deck.pageNum = deck.pageNum + 1
  api_getDecks()
end

function searchDecks(searchTerm)
  deck.searchTerm = searchTerm

  if deck.searchDelay then
    Wait.stop(deck.searchDelay)
    deck.searchDelay = nil
  end

  deck.searchDelay = Wait.time(function()
    deck.pageNum = 0
    api_getDecks()
    deck.searchDelay = nil
  end, 0.5)
end

function clueEntered(player, value)
  -- Because of how MoonSharp handles its matching expressions,
  -- absolutely no expression matching from the string library can be used for unicode clues.
  -- It converts all characters to values 0..255 before running the expression on it.
  -- eg. %s will match all characters with codes 0x0A, 0x20, 0x10A, 0x400A, 0x7020
  -- string.lower upper find etc. work fine and properly even for other character sets

  local color = player.color
  local newLineInd = string.find(value, "\n")
  if newLineInd == nil then
    -- Save the clue for when the user presses enter
    currentEnteredClue[color] = value
  else
    -- Get the clue from before the user pressed enter
    if currentEnteredClue[color] then
      value = currentEnteredClue[color]
      currentEnteredClue[color] = nil
    else
      value = ""
    end

    -- Reset the text box
    local resetInput = {
      text          = "",
      placeholder   = "Enter clue here"
    }
    UI.setAttributes(color:lower() .. "ClueText", resetInput)

    --if the clue is empty then do nothing
    if #value == 0 then
      return
    end

    -- if the game hasn't been started, a clue cannot be entered
    if gameState.status ~= 1 then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You must start a game to enter a clue! [a020f0]«")
      return
    end

    -- Make sure that it's the current codemaster's turn
    if (color == "Blue" and gameState.turnTracker == 0) or (color == "Red" and gameState.turnTracker == 1) then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to enter a clue! [a020f0]«")
      return
    end

    -- if the clue is long, dont bother processing it
    if #value > 50 then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. Please enter a valid clue and push ENTER! [a020f0]«")
      return
    end

    -- Parse the entered clue into its respective parts
    local clue, number, error = getClueDetails(value)

    -- Handle clue parsing errors
    if error then
      -- Clue wasn't able to be parsed - general error
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. Please enter a valid clue and push ENTER! [a020f0]«")
      return
    elseif number != "inf" and tonumber(number) > 9 then
      -- Clue was larger than 9 words (not 0 or inf)
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Clues cannot be for more than 9 words. [a020f0]«")
      return
    elseif string.len(clue) > 20 then
      -- Clue was larger than 20 characters
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Clues cannot be longer than 20 characters. [a020f0]«")
      return
    end

    -- Standardize clue to lowercase
    clue = clue:lower()

    -- Don't allow a clue that isn't covered
    for cardIndex, cardData in ipairs(cards) do
      if not cardData.covered and cardData.value:lower() == clue:lower() then
        Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. That word has not been covered yet, so it may not be used! [a020f0]«")
        return
      end
    end

    -- Track remaining clues
    if number == "inf" then
      gameState.guessesLeft = -1
    elseif tonumber(number) == 0 then
      gameState.guessesLeft = -1
    else
      gameState.guessesLeft = tonumber(number) + 1
    end

    -- Encode the finished clue
    encodeClue(color, clue .. " - " .. number:gsub("inf", "∞"))

    -- Enable voting for the current team
    gameState.canVote = true

    -- Send analytics data for the new clue
    api_newClue(clue, (number == "inf" and -1 or number), Player[color].steam_id)
  end
end

function getClueDetails(processedClue)
  local clueState = {}
  clueState.PRE_WHITESPACE = 1
  clueState.INF_N = 2
  clueState.INF_I = 3
  clueState.NUMBER = 4
  clueState.INF_WHITESPACE = 5 -- inf must have 1 space before clue
  clueState.PRE_CLUE_WHITESPACE = 6 -- this state allows for 1 hyphen
  clueState.CLUE = 7 -- the clue allows 1 hyphen
  clueState.CLUE_ON_HYPHEN = 8
  clueState.POST_WHITESPACE = 9

  local clue = ""
  local number = ""

  local invalid = false
  local state = clueState.PRE_WHITESPACE
  local hyphenCount = 0
  -- process clue backwards as it is easier
  for ind = #processedClue, 1, -1 do
    -- This state machine will detect an invalid clue and stop processing if it
    -- finds an invalid character before it reaches the beginning of the input
    local ch = string.sub(processedClue,ind,ind)
    local code = string.unicode(ch)
    if state == clueState.PRE_WHITESPACE then
      if string.lower(ch) == "f" then
        state = clueState.INF_N
        number = "inf"
      elseif digitCharacters[code] then
        state = clueState.NUMBER
        number = digitCharacters[code]..number
      elseif whitespaceCharacters[code] then
        -- continue
      else
        invalid = true
      end
    elseif state == clueState.INF_N then
      if string.lower(ch) == "n" then
        state = clueState.INF_I
      else
        invalid = true
      end
    elseif state == clueState.INF_I then
      if string.lower(ch) == "i" then
        state = clueState.INF_WHITESPACE
      else
        invalid = true
      end
    elseif state == clueState.NUMBER then
      if digitCharacters[code] then
        number = digitCharacters[code]..number
      elseif whitespaceCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
        hyphenCount = hyphenCount + 1
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        hyphenCount = 0
        clue = ch..clue
      end
    elseif state == clueState.INF_WHITESPACE then
      if whitespaceCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
        hyphenCount = hyphenCount + 1
      else
        invalid = true
      end
    elseif state == clueState.PRE_CLUE_WHITESPACE then
      if whitespaceCharacters[code] then
        -- continue
      elseif hyphenCharacters[code] and hyphenCount < 1 then
        hyphenCount = hyphenCount + 1
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        hyphenCount = 0
        clue = ch..clue
      end
    elseif state == clueState.CLUE or state == clueState.CLUE_ON_HYPHEN then
      if whitespaceCharacters[code] then
        if state == clueState.CLUE_ON_HYPHEN then
          invalid = true
        end
        state = clueState.POST_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.CLUE_ON_HYPHEN
        hyphenCount = hyphenCount + 1
        if hyphenCount > 1 then
          invalid = true
        end
        clue = ch..clue
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        clue = ch..clue
      end
    elseif state == clueState.POST_WHITESPACE then
      if whitespaceCharacters[code] then
        -- continue
      else
        invalid = true
      end
    else
      invalid = true -- we should never reach here
    end

    if invalid then
      -- This is an invalid clue
      -- print("c:", clue, " n:", number, " i:", ind, " ch:", ch, " code:", code, " state:", state)
      return nil, nil, true
    end
  end

  if not (state == clueState.CLUE or state == clueState.POST_WHITESPACE) or clue == "" then
    -- We either ended on a hyphen or did not receive a parsable clue
    return nil, nil, true
  end

  -- Clean number value
  if number != "inf" then
    number = tostring(tonumber(number))
  end

  -- Return the clue and number
  return clue, number, false
end

function rotateclues()
  for cardIndex, cardData in ipairs(cards) do
    local card = getObjectFromGUID(cardData.guid)
    if card.interactable then
      card.setRotation({0, 180, 0})
    end
  end
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local token = color == "Red" and redToken or blueToken
  local broadcastTo = color == "Red" and {"Orange", "Yellow", "Pink", "Brown"} or {"Teal", "Purple", "Green", "White"}

  local clues = color == "Red" and gameState.redClues or gameState.blueClues
  local xPos = color == "Red" and -21.05 or 21.05
  local deletedClues = false
  local validClues = {}

  -- Check for deleted clues and shift the remaining if need be
  if #clues > 0 then
    -- Check for deleted clues
    for _,clue in ipairs(color == "Red" and gameState.redClues or gameState.blueClues) do
      if getObjectFromGUID(clue) ~= nil then
        table.insert(validClues, clue)
      else
        deletedClues = true
      end
    end
  end

  if deletedClues then
    if color == "Red" then
      gameState.redClues = validClues
    else
      gameState.blueClues = validClues
    end
    for i, clue in ipairs(validClues) do
      local clueObject = getObjectFromGUID(clue)
      clueObject.setPosition({xPos, 1.5, (12 - (((i - 1) % 8) * 2.05))})
      clueObject.setRotation({0, 180, 0})
    end
  end
  local finishedClue = token.clone({
    position     = token.getPosition(),
    snap_to_grid = true,
    callback_function = function(clue) table.insert(color == "Red" and gameState.redClues or gameState.blueClues, clue.guid) end
  })
  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition({xPos, 1.5, (12 - ((#(color == "Red" and gameState.redClues or gameState.blueClues) % 8) * 2.05))})
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.drag_selectable = false
  finishedClue.setLuaScript(
    "function onload()\n"
      .. "self.createButton({\n"
        .. "label='" .. clue .. "', click_function='nullFunction', function_owner=self,\n"
        .. "position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}\n"
      .. "})\n"
    .. "end\n"
  )
  printToAll("[a020f0]» " .. (color == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's clue is: " .. (color == "Red" and "[da1918]" or "[1f87ff]") .. clue .. " [a020f0]«")
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("[a020f0]» [ffffff]Your clue is: " .. (color == "Red" and "[da1918]" or "[1f87ff]") .. clue .. " [a020f0]«")
  end
end

function onObjectEnterContainer(deck, card)
  -- First to check that we only do this on the first grouping
  if #deck.getObjects() == 2 then
    deck.destruct()
    Wait.frames(function() dealCards() end, 180)
  end
end

function onPlayerConnect(player)
  -- Send analytics disclaimer
  player.print(chatDisclaimer, {1, 1, 1})

  -- Check the blacklist for the player
  WebRequest.get(analytics.url .. "/games/player/blacklisted/" .. player.steam_id, function(responseRaw)
    if responseRaw.is_done then
      local response = JSON.decode(responseRaw.text)

      if response.record and response.record.dateAdded ~= nil then
        if settings.automod.autokick then
          player.kick()
        end
        printToAll("\n", {1, 1, 1})
        printToAll(player.steam_name .. " was found in the global Codenames blacklist!", redColor)
        printToAll("SteamID     : " .. player.steam_id, redColor)
        printToAll("Date Added  : " .. response.record.dateAdded, redColor)
        printToAll("Reason      : " .. response.record.reason, redColor)
        printToAll("\n", {1, 1, 1})
      end
    end
  end)
end

function onPlayerDisconnect(player)
  -- Destroy the timer for the disclaimer, if one exists
  Timer.destroy(player.steam_id)

  -- End session with player if one exists
  if gameState.status == 1 then
    if analytics.sessions[player.steam_id] ~= nil then
      api_playerSessionEnd(analytics.sessions[player.steam_id])
    end
  end
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Reset the player's vote (if necessary)
  if gameState.status == 1 then
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
      if not Player[playerColor].seated and voteData ~= 0 then
        local card = voteData
        voteData = 0
        updateVoteUI(card)
      end
    end
  end

  local endSession = {}

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team = "Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if analytics.sessions[spec.steam_id] ~= nil then
        table.insert(endSession, analytics.sessions[spec.steam_id])
      end
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team = "None"
    end
  end

  if color ~= "Grey" and color ~= "Black" then
    if gameState.status == 1 and analytics.sessions[Player[color].steam_id] == nil then
      api_playerSessionStart(Player[color].steam_id)
    end
  elseif gameState.status == 1 and (color == "Grey" or color == "Black") and #endSession ~= 0 then
    for _, sessionID in ipairs(endSession) do
      api_playerSessionEnd(sessionID)
    end
  end
end

function startTime()
  if settings.timer.enabled then
    if gameState.firstTurn then
      tableObject.call("startTimer", settings.timer.initial * 60)
    else
      tableObject.call("startTimer", settings.timer.subsequent * 60)
    end
  end
end

-- Deck fetching
function setDeck(deckID)
  if deckID == nil then
    deck.selected = {}
    return
  end

  if not deck.multiple then
    deck.selected = { deckID }
  else
    local exists = 0
    for deckIndex, deckGUID in ipairs(deck.selected) do
      if deckGUID == deckID then
        exists = deckIndex
      end
    end

    if exists == 0 then
      -- Insert the deck into the selected list
      table.insert(deck.selected, deckID)
    else
      -- Remove the deck from the list
      table.remove(deck.selected, exists)
    end
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function startGame(player)
  -- Check to see whether a new game is currently being set up
  if gameState.status == 0 then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]A new game is already starting. Please wait. [a020f0]«")
    return
  end

  -- Check to see if a deck has been chosen
  if #deck.selected == 0 then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You must select a deck before starting. [a020f0]«")
    return
  end

  -- A new game is currently starting - block any other new game requests
  gameState.status = 0

  -- Reset the game to its original state
  resetGame()

  if settings.playerShuffle then
    startLuaCoroutine(tableObject, "shufflePlayers")
  elseif settings.codemasterQueue then
    startLuaCoroutine(tableObject, "swapCodemasters")
  else
    api_gameStart()
  end
end

function resetGame()
  -- Reset card data
  for cardNum, cardData in ipairs(cards) do
    local cardObject = getObjectFromGUID(cardData.guid)
    if cardObject then
      cardObject.interactable = true
      cardObject.setLock(false)
    end

    cardData.id       = nil
    cardData.value    = nil
    cardData.color    = nil
    cardData.covered  = false
  end

  -- Reset the agent cards to their start positions
  for guid, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(guid)
    if agentObject then
      local isExtraCard = (agentObject.guid == extraBlue.guid) or (agentObject.guid == extraRed.guid)
      agentObject.interactable = not isExtraCard
      agentObject.setLock(isExtraCard)
      agentObject.setPositionSmooth(isExtraCard and {0, -2, -14} or agentData.position)
      agentObject.setRotationSmooth({0, 180, 180})
      agents[agentObject.guid].enabled = not isExtraCard
      agents[agentObject.guid].covering = nil
    end
  end

  -- Delete clue tiles
  for _, clueList in ipairs({gameState.redClues, gameState.blueClues}) do
    for _, clue in ipairs(clueList) do
      local clueTile = getObjectFromGUID(clue)
      if clueTile then
        clueTile.destruct()
      end
    end
  end

  -- Reset team votes
  for turnNum, team in pairs(votes) do
    for seatColor, vote in pairs(team) do
      votes[turnNum][seatColor] = 0
    end
  end

  -- Reset game state variables
  gameState.firstTurn   = true
  gameState.guessesLeft = -1
  gameState.canVote     = false
  gameState.redClues    = {}
  gameState.blueClues   = {}
end

function setupGame()
  -- Determine which team should go first (0 = RED; 1 = BLUE)
  gameState.turnTracker = math.random(2) - 1

  -- Shuffle the keymap
  local bank = {"Red", "Red", "Red", "Red", "Red", "Red", "Red", "Red", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "White", "White", "White", "White", "White", "White", "White", "Black"}
  if gameState.turnTracker == 0 then
    -- Add another red
    bank = table.insert(bank, "Red")
  else
    -- Add another blue
    bank = table.insert(bank, "Blue")
  end

  local words = deck.words

  for i = 1, 25, 1 do
    local nextCard = table.remove(words, math.random(1, #words))
    cards[i].id     = nextCard.id
    cards[i].value  = nextCard.word:upper()
    cards[i].color  = table.remove(bank, math.random(1, #bank))
  end

  -- Choose the correct double agent card for which team goes first
  local extraCard = gameState.turnTracker == 0 and extraRed or extraBlue

  -- Set the correct double card to red
  extraCard.setLock(false)
  extraCard.setPositionSmooth(agents[extraCard.guid].position)
  extraCard.interactable = true
  agents[extraCard.guid].enabled = true

  -- Change the turn indicator
  local previousTurn = (gameState.turnTracker == 0 and "blue" or "red") .. "Turn"
  local currentTurn = (gameState.turnTracker == 0 and "red" or "blue") .. "Turn"
  local teamColorTurn = gameState.turnTracker == 0 and "Red" or "Blue"
  tableObject.UI.setAttribute(previousTurn, "active", false)
  tableObject.UI.setAttribute(currentTurn, "active", true)
  tableObject.UI.setAttribute(previousTurn .. "BG", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "BG", "active", true)
  tableObject.UI.setAttribute("timer", "outline", teamColorTurn)
  printToAll("[a020f0]» " .. (teamColorTurn == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's turn! [a020f0]«")

  dealCards()

  -- Start the timer
  gameState.firstTurn = true
end

-- Deals the cards on the board
function dealCards()
  for i = 1, 25, 1 do
    local cardObject = getObjectFromGUID(cards[i].guid)
    if cards[i].guid == nil or cardObject == nil then
      -- Get new card if it doesn't exist
      local c = cardTemplates.takeObject({
        position            = {cards[i].position.x, 1.03, cards[i].position.z},
        rotation            = {0, 180, 0},
        snap_to_grid        = true,
        callback_function   = function(card) setCardData(card, i) end
      })
    else
      -- Set the UI
      setCardData(cardObject, i)
    end
  end
end

function setCardData(card, i)
  cards[i].guid = card.guid

  card.call("setData", {
    position  = cards[i].position,
    text      = cards[i].value,
    color     = cards[i].color
  })

  card.setLock(false)
  card.drag_selectable = false

  card.setName(cards[i].value)

  -- Once the last card has loaded in, allow a new game to be started
  if i == 25 and gameState.status == 0 then
    startTime()
    gameState.status = 1
  end
end

function findClosestCard(threshold, position)
  local closestCard =
  {
    index = nil,
    distance = nil
  }

  for cardIndex,_ in ipairs(cards) do
    local dX = position.x - cards[cardIndex].position.x
    local dZ = position.z - cards[cardIndex].position.z

    local d = math.sqrt((dX^2) + (dZ^2))

    if d < threshold then
      if closestCard.index == nil or d < closestCard.distance then
        closestCard.index = cardIndex
        closestCard.distance = d
      end
    end
  end

  return closestCard.index
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if gameState.status ~= 1 or agent.tag ~= "Tile" or agents[agent.guid] == nil then
    return
  end

  -- Find the closest card position to the dropped agent
  local cardIndex = findClosestCard(1.65, agent.getPosition())
  if cardIndex == nil or cards[cardIndex].covered then
    -- Either no close card found, or card is already covered
    agent.setPositionSmooth(agents[agent.guid].position)
    return
  end

  -- Check to see if the agent and the card are the same color
  local agentColor = agents[agent.guid].color
  local cardColor = cards[cardIndex].color
  if cardColor ~= agentColor then
    agent.setPositionSmooth(agents[agent.guid].position)
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]An agent has been placed incorrectly. You placed a " .. agentColor .. " agent on a " .. cardColor .. " card. [a020f0]«")
    return
  end

  -- Card has been marked correctly
  gameState.guessesLeft = gameState.guessesLeft - 1
  cards[cardIndex].covered = true

  coverCard(cardIndex, agent.guid)

  -- Send analytics data for the guess
  local players = ""
  local correct = ((gameState.turnTracker == 0 and cardColor == "Red") or (gameState.turnTracker == 1 and cardColor == "Blue")) and "TRUE" or "FALSE"
  for color,_ in pairs(votes[gameState.turnTracker]) do
    if Player[color].seated then
      players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
    end
  end
  api_clueGuess(players, cards[cardIndex].id, correct, cardColor:upper())

  local messageColor = {
    ["Red"] = "da1918",
    ["Blue"] = "1f87ff",
    ["White"] = "ffffff",
    ["Black"] = "191919"
  }

  if correct == "TRUE" then
    -- Play the correct sound effect
    tableObject.AssetBundle.playTriggerEffect(0)
    printToAll("[a020f0]» [31b32b][✓] [" .. messageColor[cardColor] .. "]" .. cardColor:upper() .. " [ffffff]team has correctly guessed: [" .. messageColor[cardColor]  .."]" .. cards[cardIndex].value:upper() .. " [a020f0]«")
  else
    -- Play the wrong sound effect
    tableObject.AssetBundle.playTriggerEffect(1)
    local guessingTeam = gameState.turnTracker == 0 and "Red" or "Blue"
    printToAll("[a020f0]» [da1918][✗] [" .. messageColor[guessingTeam] .. "]" .. guessingTeam:upper() .. " [ffffff]team has incorrectly guessed: [" .. messageColor[cardColor]  .."]" .. cards[cardIndex].value:upper() .. " [a020f0]«")
  end

  -- Check to see if either red or blue won
  local redWon = true
  local blueWon = true
  for i = 1, 25, 1 do
    if cards[i].color == "Red" and not cards[i].covered then
      redWon = false
    elseif cards[i].color == "Blue" and not cards[i].covered then
      blueWon = false
    end

    if not redWon and not blueWon then
      -- Skip unnecessary iterations
      break
    end
  end

  if agentColor == "Black" or blueWon or redWon then
    -- End game scenario

    -- Analytics data for end of game
    if (agentColor == "Black" and gameState.turnTracker == 0) or blueWon then
      -- Red placed black card, blue wins
      -- or blue placed all of their cards
      broadcastToAll("[a020f0]» [1f87ff]BLUE [ffffff]team wins! [a020f0]«")
      api_gameEnd("BLUE")
    elseif (agentColor == "Black" and gameState.turnTracker == 1) or redWon then
      -- Blue placed black card, red wins
      -- or red placed all of their cards
      broadcastToAll("[a020f0]» [da1918]RED [ffffff]team wins! [a020f0]«")
      api_gameEnd("RED")
    end

    -- Move the remaining agents to their codes
    endGame()
  elseif gameState.guessesLeft == 0 or agentColor == "White" or (agentColor == "Red" and gameState.turnTracker == 1) or (agentColor == "Blue" and gameState.turnTracker == 0) then
    toggleTurns()
  else
    -- Show the pass turn button and change color
    tableObject.UI.setAttributes("passTurn", {
      color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
      active = true
    })
  end
end

function playerVote(color, card)
  -- Update the player's vote
  if color == "Grey" then
    -- Ignore votes from spectators
    return
  end

  if color == "Red" or color == "Blue" or color == "Black" then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You cannot vote! [a020f0]«")
    return
  elseif votes[gameState.turnTracker][color] == nil then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to vote! [a020f0]«")
    return
  elseif not gameState.canVote then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You can't vote until you've been given a clue! [a020f0]«")
    return
  end

  if votes[gameState.turnTracker][color] == 0 then
    votes[gameState.turnTracker][color] = card
    updateVoteUI(card)
  else
    if votes[gameState.turnTracker][color] == card then
      -- Remove this player's vote
      votes[gameState.turnTracker][color] = 0
      updateVoteUI(card)
    else
      -- Switch the player's current vote to this card
      local previous = votes[gameState.turnTracker][color]
      votes[gameState.turnTracker][color] = card
      updateVoteUI(previous)
      updateVoteUI(card)
    end
  end

  -- Check to see if a vote has passed
  local votePassed = false
  local voteCard = nil
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if Player[playerColor].seated and not Player[playerColor].blindfolded then
      if (voteCard == nil and voteData ~= 0) or voteData == voteCard then
        votePassed = true
        voteCard = voteData
      else
        votePassed = false
        break
      end
    end
  end

  if votePassed then
    -- Remove all vote indicators and reset votes
    local cardsToClear = {}
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
      -- Update the vote UI first
      if voteData ~= 0 then
        table.insert(cardsToClear, voteData)
        votes[gameState.turnTracker][playerColor] = 0
      end
    end

    for _, card in ipairs(cardsToClear) do
      updateVoteUI(card)
    end

    -- Vote passed to pass turn
    if card == 26 then
      toggleTurns()
      return
    end

    -- Card has been marked correctly
    gameState.guessesLeft = gameState.guessesLeft - 1
    cards[card].covered = true

    -- Cover the card
    coverCard(card, nil)

    -- Send analytics data for the guess
    local players = ""
    local correct = ((gameState.turnTracker == 0 and cards[card].color == "Red") or (gameState.turnTracker == 1 and cards[card].color == "Blue")) and "TRUE" or "FALSE"
    for color,_ in pairs(votes[gameState.turnTracker]) do
      if Player[color].seated then
        players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
      end
    end
    api_clueGuess(players, cards[card].id, correct, cards[card].color:upper())

    local messageColor = {
      ["Red"] = "da1918",
      ["Blue"] = "1f87ff",
      ["White"] = "ffffff",
      ["Black"] = "191919"
    }

    if correct == "TRUE" then
      -- Play the correct sound effect
      tableObject.AssetBundle.playTriggerEffect(0)
      printToAll("[a020f0]» [31b32b][✓] [" .. messageColor[cards[card].color] .. "]" .. cards[card].color:upper() .. " [ffffff]team has correctly guessed: [" .. messageColor[cards[card].color]  .."]" .. cards[card].value:upper() .. " [a020f0]«")
    else
      -- Play the wrong sound effect
      tableObject.AssetBundle.playTriggerEffect(1)
      local guessingTeam = gameState.turnTracker == 0 and "Red" or "Blue"
      printToAll("[a020f0]» [da1918][✗] [" .. messageColor[guessingTeam] .. "]" .. guessingTeam:upper() .. " [ffffff]team has incorrectly guessed: [" .. messageColor[cards[card].color]  .."]" .. cards[card].value:upper() .. " [a020f0]«")
    end

    -- Check to see if either red or blue won
    local redWon = true
    local blueWon = true
    for i = 1, 25, 1 do
      if cards[i].color == "Red" and not cards[i].covered then
        redWon = false
      elseif cards[i].color == "Blue" and not cards[i].covered then
        blueWon = false
      end

      if not redWon and not blueWon then
        -- Skip unnecessary iterations
        break
      end
    end

    if cards[card].color == "Black" or blueWon or redWon then
      -- End game scenario

      if (cards[card].color == "Black" and gameState.turnTracker == 0) or blueWon then
        -- Red placed black card, blue wins
        -- or blue placed all of their cards
        broadcastToAll("[a020f0]» [1f87ff]BLUE [ffffff]team wins! [a020f0]«")
        api_gameEnd("BLUE")
      elseif (cards[card].color == "Black" and gameState.turnTracker == 1) or redWon then
        -- Blue placed black card, red wins
        -- or red placed all of their cards
        broadcastToAll("[a020f0]» [da1918]RED [ffffff]team wins! [a020f0]«")
        api_gameEnd("RED")
      end

      -- Move the remaining agents to their codes
      endGame()

    elseif gameState.guessesLeft == 0 or cards[card].color == "White" or (cards[card].color == "Red" and gameState.turnTracker == 1) or (cards[card].color == "Blue" and gameState.turnTracker == 0) then
      toggleTurns()
    else
      -- Show the pass turn button and change color
      tableObject.UI.setAttributes("passTurn", {
        color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
        active = true
      })
    end
  end
end

function coverCard(cardIndex, agentGUID)
  local cardObject = getObjectFromGUID(cards[cardIndex].guid)
  for guid, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(guid)
    if agents[guid].enabled and agentData.color == cards[cardIndex].color and agentObject and agentObject.interactable and (agentGUID == nil or agentGUID == guid) then
      local position = {cards[cardIndex].position.x, 1.03, cards[cardIndex].position.z}

      -- Track the index of the card this agent is covering
      agents[guid].covering = cardIndex

      -- Lock both cards and set them in place
      cardObject.interactable = false
      agentObject.interactable = false

      cardObject.setLock(true)
      agentObject.setLock(true)

      -- Ensure the tile is on the code
      cardObject.setRotationSmooth({0, 180, 0})
      agentObject.setRotationSmooth({0, 180, 180})

      cardObject.setPositionSmooth(position)
      agentObject.setPositionSmooth(position)
      break
    end
  end
end

function updateVoteUI(card)
  local uiObject = card == 26 and tableObject or getObjectFromGUID(cards[card].guid)

  local votesToAdd = {}
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if voteData == card then
      votesToAdd[playerColor] = true
    end
  end
  local votesOnCard =
  {
    uiObject.UI.getAttribute("vote-1", "color"),
    uiObject.UI.getAttribute("vote-2", "color"),
    uiObject.UI.getAttribute("vote-3", "color"),
    uiObject.UI.getAttribute("vote-4", "color")
  }
  local newVotes = {}

  -- Keep the order of the current votes
  for voteIndex, voteColor in ipairs(votesOnCard) do
    if voteColor ~= "Black" then
      if votes[gameState.turnTracker][voteColor] == card then
        table.insert(newVotes, voteColor)
        votesToAdd[voteColor] = nil
      end
    else
      -- Add the uncounted votes
      for playerColor,_ in pairs(votesToAdd) do
        table.insert(newVotes, playerColor)
      end
      break
    end
  end

  for i = 1,4,1 do
    if newVotes[i] ~= nil then
      uiObject.UI.setAttributes("vote-" .. i, {
        color = newVotes[i],
        active = true
      })
    else
      uiObject.UI.setAttributes("vote-" .. i, {
        color = "Black",
        active = false
      })
    end
  end
end

function votePass(color)
  playerVote(color, 26)
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" and not object.spawning then
    for i = 1, 25, 1 do
      if cards[i].guid == object.guid then
        object.setVelocity({0, 0, 0})
        object.drop()
        object.setPosition({cards[i].position.x, 1.03, cards[i].position.z})
        if #Player[color].getSelectedObjects() <= 1 then
          playerVote(color, i)
        end
        break
      end
    end
  elseif agents[object.guid] ~= nil then
    -- Prevent picking up of agent tiles from anyone but red or blue
    if color ~= "Red" and color ~= "Blue" then
      object.setVelocity({0, 0, 0})
      object.drop()
      object.setPosition({agents[object.guid].position.x, 1.01, agents[object.guid].position.z})
    end
  end
end

function onPlayerAction(player, action, objects)
  local processAction     = false
  local actionsToProcess  = {
    Player.Action.PickUp,
    Player.Action.RotateIncrementalLeft,
    Player.Action.RotateIncrementalRight,
    Player.Action.RotateOver,
    Player.Action.FlipIncrementalLeft,
    Player.Action.FlipIncrementalRight,
    Player.Action.FlipOver
  }

  for _, handledAction in ipairs(actionsToProcess) do
    if action == handledAction then
      processAction = true
      break
    end
  end

  if not processAction then
    return
  end

  local objectIncludesCard = false
  local objectIncludesAgent = false

  -- See if there is a card included in the table of objects
  for _, object in ipairs(objects) do
    if isCard(object.guid) then
      objectIncludesCard = true
    elseif agents[object.guid] ~= nil then
      objectIncludesAgent = true
    end
  end

  if objectIncludesCard and (player.color == "Blue" or player.color == "Red" or player.color == "Black") then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You're not allowed to do that! [a020f0]«")
    return false
  end

  -- Disable interacting with agents if player isn't a codemaster
  if objectIncludesAgent and player.color ~= "Blue" and player.color ~= "Red" then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You're not allowed to do that! [a020f0]«")
    return false
  end

  local isPlayerTurn = (votes[gameState.turnTracker][player.color] ~= nil)
  local errorMessage

  if action == Player.Action.PickUp then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to vote! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't vote until you've been given a clue! [a020f0]«"
    end
  elseif action == Player.Action.RotateIncrementalLeft or action == Player.Action.RotateIncrementalRight or action == Player.Action.RotateOver then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't tilt cards when it's not your turn! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't tilt cards until you've been given a clue! [a020f0]«"
    end
  elseif action == Player.Action.FlipIncrementalLeft or action == Player.Action.FlipIncrementalRight or action == Player.Action.FlipOver then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't flip cards when it's not your turn! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't flip cards until you've been given a clue! [a020f0]«"
    end
  end

  if errorMessage ~= nil then
    player.broadcast(errorMessage, redColor)
    return false
  end
end

function isCard(guid)
  for _, cardData in ipairs(cards) do
    if guid == cardData.guid then
      return true
    end
  end
  return false
end

function endGame()
  -- Disable voting for any teams
  gameState.canVote = false

  -- Set the game back to initial state
  gameState.status = -1

  -- Stop the timer
  tableObject.call("stopTimer", true)

  -- Hide the pass turn button and change color
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Assign remaining agents to uncovered clues
  for i = 1, 25, 1 do
    if not cards[i].covered then
      coverCard(i, nil)
    end
  end
end

function timeExpired()
  -- Play the timer expired sound
  tableObject.AssetBundle.playTriggerEffect(2)

  toggleTurns()
end

-- Command implementations
function onChat(message, player)
  if not player.admin then
    return
  end

  local command, color = processChat(message)
  local ranCommand = false

  if command == nil then
    return
  end

  if command == "!kick" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if not Player[color].seated then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has kicked " .. Player[color].steam_name .. ".", redColor)
    Player[color].kick()
    ranCommand = true
  elseif command == "!blind" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if not Player[color].seated then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has " .. (not Player[color].blindfolded and "blindfolded " or "unblindfolded ") .. Player[color].steam_name .. ".", redColor)
    Player[color].blindfolded = not Player[color].blindfolded
    ranCommand = true
  elseif command == "!stand" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if not Player[color].seated then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has stood " .. Player[color].steam_name .. ".", redColor)
    Player[color].changeColor("Grey")
    ranCommand = true
  end

  if ranCommand then
    return false
  end
end

function isColor(userColor)
  for _, color in ipairs(Player.getColors()) do
    if color ~= "Grey" and color:lower() == userColor:lower() then
      return true
    end
  end
  return false
end

function processChat(message)
  local raw = string.gmatch(message, "%S+")
  local firstWord = true
  local command = nil
  local args = ""
  for word in raw do
    if firstWord then
      if word:sub(1, 1) ~= "!" then
        return command, args
      else
        command = word
        firstWord = false
      end
    else
      args = args .. word .. " "
    end
  end

  return command, args:gsub("^%s*(.*%S+)%s*$", "%1"):gsub("^%s+$","")
end

function toggleTurns()
  -- Diable voting for the current team
  gameState.canVote = false

  -- Remove all vote indicators and reset votes
  local cardsToClear = {}
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    -- Update the vote UI first
    if voteData ~= 0 then
      table.insert(cardsToClear, voteData)
      votes[gameState.turnTracker][playerColor] = 0
    end
  end

  for _, card in ipairs(cardsToClear) do
    updateVoteUI(card)
  end

  -- Disable card tilting
  for _, card in ipairs(cards) do
    if not card.covered then
      local cardObject = getObjectFromGUID(card.guid)
      if settings.cardTilting then
        cardObject.setLock(true)
      end
      cardObject.setRotationSmooth({0, 180, 0})
    end
  end

  -- Hide the pass turn button
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  gameState.firstTurn = false

  -- Reset the guesses each team has left
  gameState.guessesLeft = -1

  -- Reset the clueID
  analytics.clueID = nil

  -- Play the button press effect
  local button = (gameState.turnTracker == 0 and buttonRed or buttonBlue)
  button.AssetBundle.playTriggerEffect(0)

  -- Change the tracker to the other team's turn
  gameState.turnTracker = (gameState.turnTracker == 0 and 1 or 0)

  -- Change the location of the turn marker
  local previousTurn = (gameState.turnTracker == 0 and "blue" or "red") .. "Turn"
  local currentTurn = (gameState.turnTracker == 0 and "red" or "blue") .. "Turn"
  local teamColorTurn = gameState.turnTracker == 0 and "Red" or "Blue"
  tableObject.UI.setAttribute(previousTurn, "active", false)
  tableObject.UI.setAttribute(currentTurn, "active", true)
  tableObject.UI.setAttribute(previousTurn .. "BG", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "BG", "active", true)
  tableObject.UI.setAttribute("timer", "outline", teamColorTurn)
  printToAll("[a020f0]» " .. (teamColorTurn == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's turn! [a020f0]«")

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    -- Is it the current side's turn?
    if gameState.turnTracker == 0 and button.guid == buttonBlue.guid or gameState.turnTracker == 1 and button.guid == buttonRed.guid then
      return
    end

    toggleTurns()

  end
end

function updateDecks(response)
  local totalDecks  = response["decks"]["totalDecks"]
  local deckList    = response["decks"]["deckList"]

  deck.totalDecks = tonumber(totalDecks)

  for i = 1, 20, 1 do
    if deckList[i] then
      tableObject.UI.setAttribute("deck" .. i .. "Button", "onClick", "setDeck(" .. deckList[i]["deckID"] .. ")")
      -- Deck image
      if deckList[i]["author"]["steamID"] == nil then
        tableObject.UI.setAttribute("deck" .. i .. "Official", "active", true)
        tableObject.UI.setAttribute("deck" .. i .. "Image", "active", false)
      elseif deckList[i]["author"]["profilePicture"] then
        tableObject.UI.setAttribute("deck" .. i .. "Official", "active", false)
        local assets = UI.getCustomAssets()

        local addCustomAsset = true
        for _,asset in ipairs(assets) do
          if asset["name"] == deckList[i]["author"]["steamID"] then
            addCustomAsset = false
            break
          end
        end
        if addCustomAsset then
          UI.setCustomAssets(table.insert(assets, {
            name  = deckList[i]["author"]["steamID"],
            url   = deckList[i]["author"]["profilePicture"]:gsub(".jpg", "_full.jpg")
          }))
        end
        tableObject.UI.setAttributes("deck" .. i .. "Image", {
          active  = true,
          image   = deckList[i]["author"]["steamID"]
        })
      end

      tableObject.UI.setAttributes("deck" .. i .. "Name", {
        text      = deckList[i]["name"]
      })
      tableObject.UI.setAttributes("deck" .. i .. "Author", {
        text    = (deckList[i]["author"]["displayName"] and ("by " .. deckList[i]["author"]["displayName"]) or "Official Deck")
      })
      tableObject.UI.setAttributes("deck" .. i .. "Description", {
        text    = deckList[i]["description"],
        active  = (deckList[i]["description"] == nil and "false" or "true")
      })

      tableObject.UI.setAttribute("deck" .. i .. "Button", "color", "#ffffff")
      for deckIndex, deckGUID in ipairs(deck.selected) do
        if deckGUID == deckList[i]["deckID"] then
          tableObject.UI.setAttribute("deck" .. i .. "Button", "color", "#aaeaa7")
          break
        end
      end

      tableObject.UI.setAttribute("deck" .. i, "active", true)
    else
      tableObject.UI.setAttribute("deck" .. i, "active", false)
    end
  end
  tableObject.UI.setValue("pageMarker", "Page: " .. deck.pageNum + 1 .. " / " .. math.ceil(deck.totalDecks / deck.pageSize))
  deck.fetchingDecks = false
end

-------------------------------------------------------------------------------
--------------------------------[[ ANALYTICS ]]--------------------------------
-------------------------------------------------------------------------------

function apiGet(api, callback)
  WebRequest.get(analytics.url .. api, callback)
end

function apiPost(api, payload, callback)
  WebRequest.post(analytics.url .. api, payload, callback)
end

function getJSON(responseRaw)
  if not responseRaw.is_done then
    -- Don't process until the response is ready
    return nil
  end

  local response = JSON.decode(responseRaw.text)

  if response.status == "error" then
    print("API Error: " .. response.message)
    return nil
  end

  return response
end

-------------- /games/decks --------------
function api_getDecks()
  deck.fetchingDecks = true
  apiGet("/games/decks?pageSize=" .. deck.pageSize .. "&pageNum=" .. deck.pageNum .. (deck.searchTerm and ("&searchTerm=" .. deck.searchTerm) or ""), api_getDecksCB)
end

function api_getDecksCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Update the deck selector
  updateDecks(response)
end

-------------- /games/player/blacklisted/:steamID --------------
function api_getBlacklistInfo(steamID)
  apiGet("/games/player/blacklisted/" .. steamID, api_getBlacklistInfoCB)
end

function api_getBlacklistInfoCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  if response.dateAdded ~= nil then
    if settings.automod.autokick then
      --player.kick()
    end
    --[[
    printToAll("\n", {1, 1, 1})
    printToAll(player.steam_name .. " was found in the global Codenames blacklist!", redColor)
    printToAll("SteamID     : " .. player.steam_id, redColor)
    printToAll("Date Added  : " .. response.dateAdded, redColor)
    printToAll("Reason      : " .. response.reason, redColor)
    printToAll("\n", {1, 1, 1})]]
  end
end

-------------- /games/start --------------
function api_gameStart()
  local request =
  {
    host    = analytics.host,
    decks   = "",
    first   = gameState.turnTracker == 0 and "RED" or "BLUE",
    players = ""
  }

  for deckIndex, deck in ipairs(deck.selected) do
    if deckIndex == 1 then
      request.decks = request.decks .. deck
    else
      request.decks = request.decks .. "," .. deck
    end
  end

  for _, player in ipairs(Player.getPlayers()) do
    local color = player.color
    if color ~= "Grey" and color ~= "Black" then
      request.players = request.players .. ((request.players == "") and player.steam_id or (',' .. player.steam_id))
    end
  end

  apiPost("/games/start", request, api_gameStartCB)
end

function api_gameStartCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Set the current game ID
  analytics.gameID = response.gameID

  -- Reset player sessions
  analytics.sessions = {}
  for _, session in ipairs(response.sessions) do
    analytics.sessions[session.steamID] = session.sessionID
  end

  -- Set the words for the current deck
  deck.words = response.words

  -- Reset the previous clue ID
  analytics.clueID = nil

  -- Continue setup of the game
  setupGame()
end

-------------- /games/end --------------
function api_gameEnd(winner)
  local request =
  {
    gameID  = analytics.gameID,
    winner  = winner
  }

  apiPost("/games/end", request, api_gameEndCB)
end

function api_gameEndCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Set the current game ID
  analytics.gameID = nil

  -- Reset player sessions
  analytics.sessions = {}

  -- Reset the clue ID
  analytics.clueID = nil
end

-------------- /games/clues/new --------------
function api_newClue(clue, number, codemaster)
  local request =
  {
    gameID      = analytics.gameID,
    clue        = tostring(clue),
    number      = tostring(number),
    codemaster  = tostring(codemaster),
    team        = tostring(gameState.turnTracker == 0 and "RED" or "BLUE")
  }

  apiPost("/games/clues/new", request, api_newClueCB)
end

function api_newClueCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  analytics.clueID = response.clueID
end

-------------- /games/clues/guess --------------
function api_clueGuess(players, guess, correct, color)
  local request =
  {
    clueID  = analytics.clueID,
    players = players,
    guess   = guess,
    correct = correct,
    color   = color
  }

  apiPost("/games/clues/guess", request, api_clueGuessCB)
end

function api_clueGuessCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end
end

-------------- /games/players/sessions/start --------------
function api_playerSessionStart(player)
  local request =
  {
    gameID  = analytics.gameID,
    player  = player
  }

  apiPost("/games/players/sessions/start", request, api_playerSessionStartCB)
end

function api_playerSessionStartCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Record the session ID
  analytics.sessions[response.steamID] = response.sessionID
end

-------------- /games/players/sessions/end --------------
function api_playerSessionEnd(sessionID)
  local request =
  {
    sessionID = sessionID
  }

  apiPost("/games/players/sessions/end", request, api_playerSessionEndCB)
end

function api_playerSessionEndCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Remove the session ID
  for steamID, sessionID in pairs(analytics.sessions) do
    if sessionID == response.sessionID then
      analytics.sessions[steamID] = nil
    end
  end
end