--[[

  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2018  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

]]

disclaimer =
[[
This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. You may, at your own
discretion, opt out of this data collection
via the checkbox below.

More info:
[8bb5ff]https://ryan6578.com/codenames/stats/privacy[-]

Statistics:
[8bb5ff]https://ryan6578.com/codenames/stats[-]
]]

chatDisclaimer =
[[

                  [da1918]ANALYTICS DISCLAIMER[-]
[-]This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. By continuing, you
acknowledge and accept this in accordance
with the privacy policy outlined below.

More info:
[8bb5ff]https://ryan6578.com/codenames/stats/privacy[-]

Statistics:
[8bb5ff]https://ryan6578.com/codenames/stats[-]

]]

redColor = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}

agentLocations =
{
  -- Assassain
  ['b97df2']={ 0.04, 2, -17.84 };
  -- Blue agents
  ['7fdaee']={ 12.34, 2, -13.97 }, ['99832c']={ 18.07, 2, -13.97 }, ['d9324a']={ 23.77, 2, -13.97 }, ['19b2d5']={ 29.47, 2, -13.97 },
  ['0f0ec0']={ 12.34, 2, -17.8  }, ['d9054c']={ 18.07, 2, -17.8  }, ['4de840']={ 23.77, 2, -17.8  }, ['05c73d']={ 29.47, 2, -17.8  };
  -- Red agents
  ['b48ed4']={ -29.32, 2, -13.97 }, ['6bb4d8']={ -23.62, 2, -13.97 }, ['9cbe84']={ -17.92, 2, -13.97 }, ['746660']={ -12.22, 2, -13.97 },
  ['4a2969']={ -29.32, 2, -17.8  }, ['e1754e']={ -23.62, 2, -17.8  }, ['b89ba7']={ -17.92, 2, -17.8  }, ['5c1be6']={ -12.22, 2, -17.8  };
  -- Civialians
  ['f6786b']={ -5.7, 2, -21.7 }, ['e44594']={ -5.7, 2, -17.84 }, ['1f53f2']={ -5.7, 2, -14 },
  ['f8f6a1']={ 0.04, 2, -21.7 },
  ['a05e4e']={ 5.74, 2, -21.7 }, ['1ebedd']={ 5.74, 2, -17.84 }, ['3d7b86']={ 5.74, 2, -14 };
  -- Double agents
  ['1e9282']={ 0.04, 2, -14 };
  ['3ef1ca']={ 0.04, 3, -14 };
}

agentColors =
{
  -- Assassain
  ['b97df2'] = 'black',

  -- Blue agents
  ['7fdaee'] = 'blue',
  ['99832c'] = 'blue',
  ['d9324a'] = 'blue',
  ['19b2d5'] = 'blue',
  ['0f0ec0'] = 'blue',
  ['d9054c'] = 'blue',
  ['4de840'] = 'blue',
  ['05c73d'] = 'blue',

  -- Red agents
  ['b48ed4'] = 'red',
  ['6bb4d8'] = 'red',
  ['9cbe84'] = 'red',
  ['746660'] = 'red',
  ['4a2969'] = 'red',
  ['e1754e'] = 'red',
  ['b89ba7'] = 'red',
  ['5c1be6'] = 'red',

  -- Civialians
  ['f6786b'] = 'white',
  ['e44594'] = 'white',
  ['1f53f2'] = 'white',
  ['f8f6a1'] = 'white',
  ['a05e4e'] = 'white',
  ['1ebedd'] = 'white',
  ['3d7b86'] = 'white',

  -- Double agents
  ['1e9282'] = 'blue',
  ['3ef1ca'] = 'red'
}

size =
{
  -- Small buttons
  small =
  {
    width     = 1800,
    height    = 1200,
    font_size = 340
  },

  -- Medium buttons
  medium =
  {
    width     = 3200,
    height    = 1200,
    font_size = 400
  },

  -- Large buttons
  large =
  {
    width     = 3200,
    height    = 4100,
    font_size = 400
  }
}

buttonColor =
{
  ["Blue"]    = {{31/255, 135/255, 255/255}, {0/255, 109/255, 235/255}, {0/255, 85/255, 184/255}},
  ["Teal"]    = {{33/255, 177/255, 155/255}, {25/255, 134/255, 117/255}, {17/255, 91/255, 79/255}},
  ["Purple"]  = {{160/255, 32/255, 240/255}, {133/255, 14/255, 207/255}, {102/255, 11/255, 159/255}},
  ["Green"]   = {{49/255, 179/255, 43/255}, {38/255, 138/255, 33/255}, {27/255, 97/255, 23/255}},
  ["White"]   = {{255/255, 255/255, 255/255}, {229/255, 229/255, 229/255}, {203/255, 203/255, 203/255}},

  ["Red"]     = {{218/255, 25/255, 24/255}, {172/255, 20/255, 19/255}, {126/255, 15/255, 14/255}},
  ["Orange"]  = {{244/255, 100/255, 29/255}, {212/255, 77/255, 10/255}, {163/255, 59/255, 8/255}},
  ["Yellow"]  = {{231/255, 229/255, 44/255}, {201/255, 199/255, 23/255}, {155/255, 154/255, 18/255}},
  ["Pink"]    = {{245/255, 112/255, 206/255}, {242/255, 64/255, 190/255}, {239/255, 16/255, 174/255}},
  ["Brown"]   = {{133/255, 59/255, 23/255}, {71/255, 37/255, 14/255}, {28/255, 15/255, 6/255}}
}

-- Color = Blue/Red/Black/White
cards =
{
  -- Row 1 (cards 1-5)
  {position = {x = -11.4, z = 12.6}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 12.6}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =     0, z = 12.6}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 12.6}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 12.6}, guid = nil, value = nil, size = nil, color = nil, covered = false},

  -- Row 2 (cards 6-10)
  {position = {x = -11.4, z = 8.75}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 8.75}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =     0, z = 8.75}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 8.75}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 8.75}, guid = nil, value = nil, size = nil, color = nil, covered = false},

  -- Row 3 (cards 11-15)
  {position = {x = -11.4, z =  4.9}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  -5.7, z =  4.9}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =     0, z =  4.9}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =   5.7, z =  4.9}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  11.4, z =  4.9}, guid = nil, value = nil, size = nil, color = nil, covered = false},

  -- Row 4 (cards 16-20)
  {position = {x = -11.4, z = 1.05}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 1.05}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =     0, z = 1.05}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 1.05}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 1.05}, guid = nil, value = nil, size = nil, color = nil, covered = false},

  -- Row 5 (cards 21-25)
  {position = {x = -11.4, z = -2.8}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = -2.8}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =     0, z = -2.8}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =   5.7, z = -2.8}, guid = nil, value = nil, size = nil, color = nil, covered = false},
  {position = {x =  11.4, z = -2.8}, guid = nil, value = nil, size = nil, color = nil, covered = false},
}

function onload(saveState)

  -- Global variables --

  -- Global game mode
  gameStarted = false
  firstTurn = true
  -- Keeps track of whether or not a new game is in the process of starting
  newGameStarting = false
  -- Keeps track of whether or not we are currently shuffling players
  shufflingPlayers = false
  -- Timer warning variable
  timerWarning = -1
  -- 0 = RED; 1 = BLUE
  turnTracker = 1

  gameStatus =
  {
    -- Tracks whether the current game has started
    started = false,

    -- Current game is on the first turn or not
    firstTurn = false,
  }

  settings =
  {
    playerShuffle = false,

    afkDetection =
    {
      enabled   = true,
      threshold = 10
    },

    timer =
    {
      enabled     = true,
      initial     = 10,
      subsequent  = 5
    },

    codemasterQueue = true
  }

  -- Used for game analytics - ryan6578.com
  analyticsLocked = false
  analytics =
  {
    -- Opt out of analytics?
    optOut = false, -- Opt out of analytics if you so wish
    url = "https://www.ryan6578.com/codenames/API/v2/",
    gameID = "",
    host = "",
    deck = "",
    clueID = nil,
    teams =
    {
      red = {},
      blue = {}
    }
  }
  for i, player in ipairs(Player.getPlayers()) do
    if player.host then
      analytics.host = player.steam_id
      break
    end
  end


  -- Illegal move tracking
  updateTimer = 0

  -- Configuration panel settings
  codemasterQueue = {}
  afkTracker = {}

  -- Tracks the amount of guesses the current team has left
  guessesLeft = -1

  -- Keep track of team announcements
  announceTracker = {}

  -- Red clue tracker
  redClues = {}
  redCluesTracker = 0

  -- Blue clue tracker
  blueClues = {}
  blueCluesTracker = 0

  -- Keeps track of the players to ignore for color switching
  playersToIgnore = {}

  -- Tracks pickup locations of agents
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  -- lights toggles
  spaceBG = getObjectFromGUID("7b8161")
  spaceBG.interactable = false
  spaceParticles = getObjectFromGUID("8430cf")
  spaceParticles.interactable = false
  ambient_bot = getObjectFromGUID("6fb111")
  ambient_bot.interactable = false
  ambient_top = getObjectFromGUID("05032c")
  ambient_top.interactable = false
  teams_red = getObjectFromGUID("a1b2cd")
  teams_red.interactable = false
  teams_blue = getObjectFromGUID("6072b1")
  teams_blue.interactable = false

  -- Control panel declarations
  gameCP = getObjectFromGUID("ec0882")
  gameCP.interactable = false
  settingsCP = getObjectFromGUID("0837df")
  settingsCP.interactable = false
  analyticsCP = getObjectFromGUID("071c46")
  if analyticsCP ~= nil then
    -- Only set to not interactable at the beginning of the game
    -- Not if a result of a rewind
    analyticsCP.interactable = false
  end
  queueCP = getObjectFromGUID("c67626")
  queueCP.interactable = false

  drawGameCP()
  drawSettingsCP()
  if analyticsCP ~= nil then
    -- Only set to not interactable at the beginning of the game
    -- Not if a result of a rewind
    drawAnalyticsCP()
  end

  deckVanilla = getObjectFromGUID("83b607")
  deckHanii = getObjectFromGUID("92bb6b")
  deckCHRY = getObjectFromGUID("41f57c")
  deckUndercover = getObjectFromGUID("ee8afd")
  deckSaydi = getObjectFromGUID("d75160")
  deckMayor = getObjectFromGUID("3a3e8c")
  deckVanilla.interactable = false
  deckHanii.interactable = false
  deckCHRY.interactable = false
  deckUndercover.interactable = false
  deckSaydi.interactable = false
  deckMayor.interactable = false

  decks = {
    -- Vanilla
    [1] = deckVanilla,

    -- Hanii
    [2] = deckHanii,

    -- CHRY
    [3] = deckCHRY,

    -- Undercover
    [4] = deckUndercover,

    -- Saydi's
    [5] = deckSaydi,

    -- Mayor's
    [6] = deckMayor
  }

  -- Until the clue announcements work
  --clueTablet = getObjectFromGUID("69b440")
  --clueTablet.interactable = false

  deckZone = getObjectFromGUID("33d9ff")

  deckDealer = getObjectFromGUID("27d226")

  zoneToClear = getObjectFromGUID("f71f4c")
  clueZone = getObjectFromGUID("f71f4c")

  buttonRed = getObjectFromGUID("f16a9a")
  buttonBlu = getObjectFromGUID("c91f34")
  buttonTeams = getObjectFromGUID("8a85e8")
  buttonTeams.interactable = false
  buttonTeams.setLock(true)

  -- Red team plaque position and rotation
  redPos = {-20.7, 0.91, 17.94}
  redRot = {0, 180, 0}

  -- Blue team plaque position and rotation
  bluePos = {20.7, 0.91, 17.94}
  blueRot = {0, 180, 180}

  clockTimer = getObjectFromGUID("0b1336")

  tileZone = getObjectFromGUID("06b292")

  buttonBlu.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- red clue encoder
  redToken = getObjectFromGUID("f3cdf2")
  redToken.interactable = false

  -- blue clue encoder
  blueToken = getObjectFromGUID("3f75b3")
  blueToken.interactable = false

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    gameStarted = decodedSaveState.gameStarted
    settings = decodedSaveState.settings
    timerWarning = decodedSaveState.timerWarning
    turnTracker = decodedSaveState.turnTracker
    first_random = decodedSaveState.first_random

    updateTimer = decodedSaveState.updateTimer

    cards = decodedSaveState.cards

  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    Timer.create({
      identifier     = "afkLoop",
      function_name  = "afkCheckLoop",
      function_owner = self,
      delay          = 1,
      repetitions    = 0
    })
  end
end

function onSave()
  local saveData = {}

  saveData.gameStarted = gameStarted
  saveData.settings = settings
  saveData.timerWarning = timerWarning
  saveData.turnTracker = turnTracker
  saveData.first_random = first_random

  saveData.updateTimer = updateTimer

  saveData.cards = cards

  return JSON.encode(saveData)
end

function nullFunction()
  -- Nothing
end

function drawGameCP()
  -- Clear all the existing buttons on the CP
  gameCP.clearButtons()

  -- Draw buttons
  makeButton(gameCP, "Vanilla\nCodenames", "resetVanilla", {x = -5.5, z = -3}, false, size.small, nil)
  makeButton(gameCP, "Hanii's\nCodenames", "resetHanii", {x = -5.5, z = 0}, false, size.small, nil)
  makeButton(gameCP, "CHRY's\nCodenames", "resetCHRY", {x = -1.5, z = -3}, false, size.small, nil)
  makeButton(gameCP, "Codenames:\nUndercover", "resetUndercover", {x = -1.5, 0, z = 0}, false, size.small, nil)
  makeButton(gameCP, "Saydi's\nCodenames", "resetSaydi", {x = -5.5, z = 3}, false, size.small, nil)
  makeButton(gameCP, "Mayor's\nCodenames", "resetMayor", {x = -1.5, z = 3}, false, size.small, nil)
  makeButton(gameCP, "New Game\n(Reset)", "newGame", {x = 4, z = 0}, false, size.large, "Green")
end

function drawSettingsCP()
  -- Clear all the existing buttons on the CP
  settingsCP.clearButtons()

  makeText(settingsCP, "Game Settings", {x = -6.75, z = 0}, true, {1, 1, 1}, 500)

  -- Draw the buttons with updated values
  makeCheckbox(settingsCP, "Shuffle Players at Start", "toggleShuffle", {x = -5.5, z = 4.15}, true, 4.2, settings.playerShuffle, false)
  makeCheckbox(settingsCP, "Enable Codemaster Queue", "toggleQueue", {x = -4.3, z = 4.15}, true, 4.6, settings.codemasterQueue, false)
  makeCheckbox(settingsCP, "AFK Detection", "toggleAFK", {x = -3.1, z = 4.15}, true, 2.8, settings.afkDetection.enabled, false)
  makeCounter(settingsCP, settings.afkDetection.threshold, "minutes", "incAFK", "decAFK", {x = -1.9, z = 3.15}, true, 2.5, not settings.afkDetection.enabled)
  makeCheckbox(settingsCP, "Timer Enabled", "toggleTimer", {x = -0.7, z = 4.15}, true, 2.8, settings.timer.enabled, false)
  makeCounter(settingsCP, settings.timer.initial, "minutes (round 1)", "incInitTimer", "decInitTimer", {x = 0.5, z = 3.15}, true, 4.0, not settings.timer.enabled)
  makeCounter(settingsCP, settings.timer.subsequent, "minutes (round 2+)", "incSubTimer", "decSubTimer", {x = 1.7, z = 3.15}, true, 4.2, not settings.timer.enabled)
end

function drawAnalyticsCP()
  -- Clear all the existing buttons on the CP
  analyticsCP.clearButtons()

  -- Draw the disclaimer
  makeText(analyticsCP, "Analytics Disclaimer", {x = 0, z = -4}, false, redColor, 500)
  makeText(analyticsCP, disclaimer, {x = 0, z = 0.35}, false, {1, 1, 1}, 300)

  -- Draw the buttons with updated values
  makeCheckbox(analyticsCP, "[8bff9b]Send usage and statistics[-]", "toggleAnalytics", {x = -4, z = 4}, false, 4.5, not analytics.optOut, analyticsLocked)
end

function makeButton(object, buttonLabel, callback, position, flip, size, colorScheme)
  local attributes =
  {
    click_function  = callback,
    function_owner  = self,
    label           = buttonLabel,
    position        = {x = position.x, y = 0.2, z = position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    width           = size.width,
    height          = size.height,
    font_size       = size.font_size
  }
  if colorScheme != nil then
    attributes.font_color   = {1, 1, 1}
    attributes.color        = buttonColor[colorScheme][1]
    attributes.hover_color  = buttonColor[colorScheme][2]
    attributes.press_color  = buttonColor[colorScheme][3]
  end
  object.createButton(attributes)
end

function makeCheckbox(object, textLabel, callback, position, flip, textOffset, checked, disabled)
  local check =
  {
    label           = (checked and "✔" or ""),
    click_function  = callback,
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 400,
    width           = 400,
    font_size       = 300
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = (flip and {(position.x + 0.1), 0.2, (position.z - textOffset)} or {(position.x + textOffset), 0.2, (position.z + 0.1)}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 350
  }
  if disabled then
    check.color = {0.5, 0.5, 0.5}
    check.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(check)
  object.createButton(text)
end

function makeText(object, contents, position, flip, color, size)
  local text =
  {
    label           = contents,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = color,
    font_size       = size
  }
  object.createButton(text)
end

function makeCounter(object, value, textLabel, incCB, decCB, position, flip, textOffset, disabled)
  local num =
  {
    label           = tostring(value),
    click_function  = "nullFunction",
    function_owner  = self,
    position        = {position.x, 0.2, position.z},
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 400,
    width           = 400,
    font_size       = 300
  }
  local text =
  {
    label           = textLabel,
    click_function  = "nullFunction",
    function_owner  = self,
    position        = (flip and {(position.x + 0.1), 0.2, (position.z - textOffset)} or {(position.x + textOffset), 0.2, (position.z + 0.1)}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 0,
    width           = 0,
    font_color      = {1, 1, 1},
    font_size       = 350
  }
  local decrement =
  {
    label           = "-",
    click_function  = decCB,
    function_owner  = self,
    position        = (flip and {position.x, 0.2, (position.z + 0.8)} or {(position.x - 0.8), 0.2, position.z}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  local increment =
  {
    label           = "+",
    click_function  = incCB,
    function_owner  = self,
    position        = (flip and {position.x, 0.2, (position.z - 0.8)} or {(position.x + 0.8), 0.2, position.z}),
    rotation        = (flip and {0, 270, 0} or {0, 0, 0}),
    height          = 250,
    width           = 250,
    font_size       = 300
  }
  if disabled then
    num.color = {0.5, 0.5, 0.5}
    num.font_color = {0.25, 0.25, 0.25}
    text.color = {0.5, 0.5, 0.5}
    text.font_color = {0.25, 0.25, 0.25}
    decrement.color = {0.5, 0.5, 0.5}
    decrement.font_color = {0.25, 0.25, 0.25}
    increment.color = {0.5, 0.5, 0.5}
    increment.font_color = {0.25, 0.25, 0.25}
  end
  object.createButton(num)
  object.createButton(text)
  object.createButton(decrement)
  object.createButton(increment)
end

function decInitTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.initial > 1 then
        settings.timer.initial = settings.timer.initial - 1
        drawSettingsCP()
      end
    end
  end
end

function incInitTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.initial < 20 then
        settings.timer.initial = settings.timer.initial + 1
        drawSettingsCP()
      end
    end
  end
end

function decSubTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.subsequent > 1 then
        settings.timer.subsequent = settings.timer.subsequent - 1
        drawSettingsCP()
      end
    end
  end
end

function incSubTimer(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.timer.enabled then
      if settings.timer.subsequent < 20 then
        settings.timer.subsequent = settings.timer.subsequent + 1
        drawSettingsCP()
      end
    end
  end
end

function decAFK(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold > 1 then
        settings.afkDetection.threshold = settings.afkDetection.threshold - 1
        drawSettingsCP()
      end
    end
  end
end

function incAFK(o, color)
  if Player[color].host or Player[color].promoted then
    if settings.afkDetection.enabled then
      if settings.afkDetection.threshold < 60 then
        settings.afkDetection.threshold = settings.afkDetection.threshold + 1
        drawSettingsCP()
      end
    end
  end
end

function toggleShuffle(o, color)
  if Player[color].host or Player[color].promoted then
    settings.playerShuffle = not settings.playerShuffle
    drawSettingsCP()
  end
end

function toggleAnalytics(o, color)
  if not analyticsLocked and Player[color].host == true then
    analytics.optOut = not analytics.optOut
    drawAnalyticsCP()
  end
end


function toggleQueue(o, color)
  if Player[color].host or Player[color].promoted then
    settings.codemasterQueue = not settings.codemasterQueue
    if settings.codemasterQueue then
      -- Show the panel
      queueCP.setRotation({0, 270, 0})
      queueCP.setPosition({-8, 0.91, -32})
    else
      -- Hide the panel
      queueCP.setPosition({-8, -0.5, -32})
      queueCP.setRotation({0, 90, 180})
    end
    drawSettingsCP()
  end
end

function afkCheckLoop()
  if settings.afkDetection.enabled then
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local players = Player.getPlayers()
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((settings.afkDetection.threshold * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end
end

function toggleAFK(o, color)
  if Player[color].host or Player[color].promoted then
    settings.afkDetection.enabled = not settings.afkDetection.enabled
    Timer.destroy("afkLoop")
    if settings.afkDetection.enabled then
      Timer.create({
        identifier     = "afkLoop",
        function_name  = "afkCheckLoop",
        function_owner = self,
        delay          = 1,
        repetitions    = 0
      })
    end
    drawSettingsCP()
  end
end

function clueEntered(player, value)
  if value:match("\n") then
    local color = player.color

    -- Reset the text box
    local resetInput = {
      text          = "",
      placeholder   = "Enter clue here"
    }
    UI.setAttributes(color:lower() .. "ClueText", resetInput)

    -- Make sure that it's the current codemaster's turn
    if (color == "Blue" and turnTracker == 0) or (color == "Red" and turnTracker == 1) then
      Player[color].broadcast("It's not your turn to enter a clue.", redColor)
      return
    end

    -- Remove the newline, trim the clue, and convert to lowercase
    value = value:gsub("\n", ""):match("%s*(.-)%s*$"):lower()

    -- Parse the entered clue into its respective parts
    local clue, number, error = getClueDetails(value)

    -- Handle clue parsing errors
    if error then
      -- Clue wasn't able to be parsed - general error
      Player[color].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
      return
    elseif number != "inf" and tonumber(number) > 9 then
      -- Clue was larger than 9 words (not 0 or inf)
      Player[color].broadcast("Clues cannot be for more than 9 words.", redColor)
      return
    elseif string.len(clue) > 20 then
      -- Clue was larger than 20 characters
      Player[color].broadcast("Clues cannot be longer than 20 characters.", redColor)
      return
    end

    -- Disable for now until I get Google TTS working
    --playClue(playerColor, clue, number)

    -- Track remaining clues
    if number == "inf" then
      guessesLeft = -1
    elseif number == "0" then
      guessesLeft = -1
    else
      guessesLeft = tostring(number) + 1
    end

    -- Encode the finished clue
    encodeClue(color, clue .. " - " .. number:gsub("inf", "∞"))

    -- Send analytics data for the a new clue
    local payload =
    {
      gameID = tostring(analytics.gameID),
      code = tostring(clue),
      number = tostring(number == "inf" and -1 or number),
      codemaster = tostring(Player[color].steam_id),
      team = tostring(turnTracker == 0 and "RED" or "BLUE")
    }
    sendAnalytics("Clues/New", payload, function(request) if request.is_done then analytics.clueID = request.text end end)
  end
end

-- Google TTS
--[[function playClue(team, clue, number)
  local message
  if number == "inf" then
    message = "The " .. team .. " team's code is, " .. clue .. ", with infinite guesses."
  elseif number == "0" then
    message = "The " .. team .. " team's code is to avoid, " .. clue .. ", with infinite guesses."
  else
    message = "The " .. team .. " team's code is, " .. clue .. ", for " .. number
    if number == "1" then
      message = message .. " word."
    else
      message = message .. " words."
    end
  end
  if not analytics.optOut then
    local payload = {
      msg = message,
      voice = "Chris",
      engine = "1"
    }
    WebRequest.post("https://www.lumenvox.com/products/tts/processTTS.ashx", payload, self, "playClueCallback")
  end
end

function playClueCallback(returnData)
  if returnData.is_done then
    local mediaFile = string.match(returnData.text, "^.+<path>(.+)</path>.+$")
    if mediaFile != nil then
      -- Ensure that the returned media file was able to be found in the return XML
      clueTablet.setValue("https://ryan6578.com/tabletopsimulator/codenames/codenames.php?tts=" .. mediaFile)
    end
  end
end]]

function getClueDetails(processedClue)
  -- How many hyphens are there?
  local clue, number
  local _, hyphenCount = string.gsub(processedClue, "%-", "")
  local _, spaceCount = string.gsub(processedClue, "%s", "")

  if hyphenCount == 0 then
    -- Single word with space (or no space) as delimiter
    if spaceCount > 1 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+)(%s*)(%d+)$",
      "^(%a+)(%s+)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  elseif hyphenCount == 1 then
    -- Either a hypenated word with a space (or no space) as delimiter
    -- or a single word with a hyphen (and possibly spaces) as delimiter
    if spaceCount > 2 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+%-%a+)(%s*)(%d+)$",
      "^(%a+%-%a+)(%s+)(inf)$",
      "^(%a+)(%s*%-%s*)(%d+)$",
      "^(%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  elseif hyphenCount == 2 then

    if spaceCount > 2 then
      return nil, nil, true
    end

    local checks = {
      "^(%a+%-%a+)(%s*%-%s*)(%d+)$",
      "^(%a+%-%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number, false
        end
      end
    end

    -- No valid clues detected
    return nil, nil, true

  else
    -- Clue has too many hyphens
    return nil, nil, true
  end
end

function rotateclues()
  local objectsInZone = clueZone.getObjects()
  for i, object in ipairs(objectsInZone) do
    local tag = object.tag
    if tag =="Card" then
      object.setRotation({0, 180, 0})
    end
  end
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local clueColor
  local broadcastTo
  if color == "Red" then
    clueColor = redColor
    finishedClue = redToken.clone({
      position     = redToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if redCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (redCluesTracker - 1) do
        if redClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = redClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        redCluesTracker = 0
        redClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            redCluesTracker = redCluesTracker + 1
          end
        end
      end
    end

    -- Set the red clue position
    redClues[redCluesTracker] = finishedClue
    cluePosition = {-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))}
    redCluesTracker = redCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Orange", "Yellow", "Pink", "Brown"}
  elseif color == "Blue" then
    clueColor = blueColor
    finishedClue = blueToken.clone({
      position     = blueToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if blueCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (blueCluesTracker - 1) do
        if blueClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = blueClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues then
        blueCluesTracker = 0
        blueClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            blueCluesTracker = blueCluesTracker + 1
          end
        end
      end
    end

    -- Set the blue clue position
    blueClues[blueCluesTracker] = finishedClue
    cluePosition = {20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))}
    blueCluesTracker = blueCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Teal", "Purple", "Green", "White"}
  end

  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition(cluePosition)
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.setLuaScript(
    "function onload()\n"
      .. "self.createButton({\n"
        .. "label='" .. clue .. "', click_function='nullFunction', function_owner=self,\n"
        .. "position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}\n"
      .. "})\n"
    .. "end\n"

    .. "function nullFunction()\n"
    .. "end\n"
  )
  printToAll(color .. " team's clue is: " .. clue, clueColor)
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("Your clue is: " .. clue, clueColor)
  end
end

function toggleTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    settings.timer.enabled = not settings.timer.enabled
    if settings.timer.enabled then
      startTime()
      printToAll("Timer Enabled", {1,1,1})
    else
      if gameStarted then
        clockTimer.setValue(0)
      end
      printToAll("Timer Disabled", {1,1,1})
    end
    drawSettingsCP()
  end
end

function deleteclues()
  -- Delete red clues
  for _, redClue in pairs(redClues) do
    if redClue != nil then
      redClue.destruct()
    end
  end
  redClues = {}
  redCluesTracker = 0

  -- Delete blue clues
  for _, blueClue in pairs(blueClues) do
    if blueClue != nil then
      blueClue.destruct()
    end
  end
  blueClues = {}
  blueCluesTracker = 0
end

function onPlayerConnect(player)
  if not analytics.optOut then
    local disclaimerParam = {}
    disclaimerParam.player = player
    Timer.create({identifier=disclaimerParam.player.steam_id, function_name='displayDisclaimer', parameters=disclaimerParam, delay=10})
  end
end

function displayDisclaimer(params)
  Timer.destroy(params.player.steam_id)
  params.player.print(chatDisclaimer, {1, 1, 1})
end

function onPlayerDisconnect(player)
  -- Destroy the timer for the disclaimer, if one exists
  Timer.destroy(player.steam_id)

  -- End session with player if one exists
  if gameStarted then
    -- Do we need to close the session
    local closeSession = false

    -- SessionID
    local sessionID = ""

    -- Remove player from team
    if analytics.teams.red[player.steam_id] ~= nil then
      sessionID = analytics.teams.red[player.steam_id]
      analytics.teams.red[player.steam_id] = nil
      closeSession = true
    elseif analytics.teams.blue[player.steam_id] ~= nil then
      sessionID = analytics.teams.blue[player.steam_id]
      analytics.teams.blue[player.steam_id] = nil
      closeSession = true
    end

    if not closeSession then
      -- Session doesn't need to be closed
      return
    end

    -- Send analytics data for the start of a game
    local payload =
    {
      sessions = tostring(sessionID)
    }
    -- Send analytics data for the start of a game
    sendAnalytics("Players/EndSession", payload, function(request) nullFunction() end)
  end
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  local endSession = {}

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team = "Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if analytics.teams.red[spec.steam_id] ~= nil or analytics.teams.blue[spec.steam_id] ~= nil then
        table.insert(endSession, #endSession + 1, spec.steam_id)
      end
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team = "None"
    end
  end

  -- Tell players which team they are on
  if color == "Red" or color == "Orange" or color == "Yellow" or color == "Pink" or color == "Brown" then
    announceTeam(color)

    -- Check if the player should be ignored
    if not shouldUpdateAnalytics(Player[color].steam_id, color) then
      return
    end

    if gameStarted then
      local payload =
      {
        players = tostring(Player[color].steam_id),
        gameID = tostring(analytics.gameID)
      }
      sendAnalytics("Players/StartSession", payload,
        function(request)
          if request.is_done then
            local response = JSON.decode(request.text)

            for steamID, token in pairs(response) do
              -- Add this player to the red team
              analytics.teams.red[steamID] = token
            end
          end
        end)
    end
  elseif color == "Blue" or color == "Teal" or color == "Purple" or color == "Green" or color == "White" then
    announceTeam(color)

    -- Check if the player should be ignored
    if not shouldUpdateAnalytics(Player[color].steam_id, color) then
      return
    end

    if gameStarted then
      local payload =
      {
        players = tostring(Player[color].steam_id),
        gameID = tostring(analytics.gameID)
      }
      sendAnalytics("Players/StartSession", payload,
        function(request)
          if request.is_done then
            local response = JSON.decode(request.text)

            for steamID, token in pairs(response) do
              -- Add this player to the blue team
              analytics.teams.blue[steamID] = token
            end
          end
        end)
    end
  elseif color == "Grey" and gameStarted then
    -- Keep track of the sessions to closes
    local sessionPayload = ""

    -- Remove players from their teams
    for i, steamID in ipairs(endSession) do
      local ignore = false

      -- Check if the player should be ignored
      if not shouldUpdateAnalytics(steamID, color) then
        ignore = true
      end

      if analytics.teams.red[steamID] ~= nil and not ignore then
        sessionPayload = sessionPayload .. ((i == 1) and analytics.teams.red[steamID] or (',' .. analytics.teams.red[steamID]))
        analytics.teams.red[steamID] = nil
      elseif analytics.teams.blue[steamID] ~= nil and not ignore then
        sessionPayload = sessionPayload .. ((i == 1) and analytics.teams.blue[steamID] or (',' .. analytics.teams.blue[steamID]))
        analytics.teams.blue[steamID] = nil
      end
    end

    if sessionPayload == "" then
      -- Nothing to send
      return
    end

    local payload =
    {
      sessions = tostring(sessionPayload)
    }
    sendAnalytics("Players/EndSession", payload, function(request) nullFunction() end)
  end
end

function announceTeam(color)
  Wait.frames(
    function()
      if Player[color].seated == false then
        return
      end
      UI.show(color .. 'Announce')
      Wait.frames(
        function()
          if Player[color].seated == false then
            UI.setAttribute(color .. 'Announce', 'active', 'false')
            return
          end
          UI.hide(color .. 'Announce')
        end, 300
      )
    end, 300
  )
end

function startTime()
  if settings.timer.enabled and gameStarted then
    if firstTurn then
      clockTimer.setValue(settings.timer.initial * 60)
    else
      clockTimer.setValue(settings.timer.subsequent * 60)
    end
    clockTimer.Clock.pauseStart()
  end
end

-- Deck fetching
function fetchDeck(deck)
  -- Clear any decks currently in the zone
  clearDeckZone(deckZone)

  local chosenDeck = decks[deck]

  -- Hybrid loading - load a new deck if one doesn't exist
  if chosenDeck.tag == "Infinite" then
    chosenDeck.takeObject({
      position          = {-9.72, -2, 17.99},
      rotation          = {0, 180, 180},
      smooth            = false,
      callback_function = function(spawnedDeck)
                            spawnedDeck.setLock(true)
                            spawnedDeck.interactable = false
                            -- Delete the infinite bag as we no longer need it
                            chosenDeck.destruct()
                            chosenDeck = spawnedDeck
                            decks[deck] = spawnedDeck

                            chosenDeck.clone({
                              position     = {-9.72, 3, 17.99},
                              snap_to_grid = true,
                              callback_function = function(deck) deck.setLock(false) end
                            })

                            -- Set the deck name for the analytics
                            analytics.deck = chosenDeck.getName()
                          end
    })
  else
    local deck = chosenDeck.clone({
      position     = {-9.72, 3, 17.99},
      snap_to_grid = true
    })
    deck.setLock(false)

    -- Set the deck name for the analytics
    analytics.deck = deck.getName()
  end
end

-- Clear decks from dealer zone
function clearDeckZone(deckZone)
  for _, object in ipairs(deckZone.getObjects()) do
    if object.tag =="Deck" then
      object.destruct()
    end
  end
end

-- Call functions get deck + clear deckZone
function resetVanilla(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(1)
  end
end

function resetHanii(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(2)
  end
end

function resetCHRY(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(3)
  end
end

function resetUndercover(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(4)
  end
end

function resetSaydi(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(5)
  end
end

function resetMayor(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    fetchDeck(6)
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function newGame(o, color)
  if color=="Red" or color=="Blue" or Player[color].admin then
    -- Check to see whether a new game is currently being set up
    if newGameStarting then
      Player[color].broadcast("A new game is already starting. Please wait.", redColor)
      return
    end

    -- A new game is currently starting - block any other new game requests
    newGameStarting = true
    gameStarted = false

    -- 1) Make sure a deck can be found
    -- 2) Clear and reset the board
    -- 3) Shuffle players/swap codemasters if necessary
    -- 4) Reset the keymap
    -- 5) Deal new cards
    -- 6) Fetch the first card for the team who goes first

    -- Find the deck currently in use
    currentDeck = findDeck()

    if currentDeck == nil then
      -- Deck was not able to be found
      newGameStarting = false
      Player[color].broadcast("You need to choose a deck before starting.", redColor)
      return
    end

    -- Reset the game to its original state
    resetGame()

    --
    if settings.playerShuffle then
      startLuaCoroutine(queueCP, "startShuffle")
    elseif settings.codemasterQueue then
      startLuaCoroutine(queueCP, "swapCodemasters")
    else
      startGame()
    end

    if not analyticsLocked then
      analyticsLocked = true
      -- Destroy the analytics CP - we no longer need it
      analyticsCP.destruct()
    end
  end
end

function sendAnalytics(api, payload, callback)
  if not analytics.optOut then
    WebRequest.post(analytics.url .. api .. "/index.php", payload, callback)
  end
end

function resetGame()
  -- Reset cards
  for i = 1, 25, 1 do
    -- Delete the instance of the card
    if cards[i].guid ~= nil then
      getObjectFromGUID(cards[i].guid).destruct()
    end

    -- Remove all card data
    cards[i].guid = nil
    cards[i].color = nil
    cards[i].covered = false
  end

  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('1e9282')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("3ef1ca")

  -- resets the agent cards to their start positions
  for guid, pos in pairs(agentLocations) do
    local card = getObjectFromGUID(guid)
    if card then
      if card.guid == doubleRed.guid then
        doubleRed.interactable = false
        doubleRed.setLock(true)
        doubleRed.setPosition({0, -2, -14})
      elseif card.guid == doubleBlue.guid then
        doubleBlue.interactable = false
        doubleBlue.setLock(true)
        doubleBlue.setPosition({0, -2, -14})
      else
        card.setPosition(pos)
        card.setRotation({0,180,180})
        card.unlock()
        card.interactable = true
      end
    end
  end

  -- Delete red clues
  for _, redClue in pairs(redClues) do
    if redClue != nil then
      redClue.destruct()
    end
  end
  redClues = {}
  redCluesTracker = 0

  -- Delete blue clues
  for _, blueClue in pairs(blueClues) do
    if blueClue != nil then
      blueClue.destruct()
    end
  end
  blueClues = {}
  blueCluesTracker = 0

  -- Reset game variables
  guessesLeft = -1
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end
end

-- Find deck on top of deck dealer
function findDeck()
    local deckObjects = deckZone.getObjects()
    local toolPos = deckDealer.getPosition()

    for i, v in pairs(deckObjects) do
        if v.tag == "Deck" then
            local vPos = v.getPosition()
            local dX = toolPos.x - vPos.x
            local dZ = toolPos.z - vPos.z
            if dX<1 and dX>-1 and dZ<1 and dZ>-1 then
              -- Suitable deck found
              return v
            end
        end
    end

    -- No deck was found
    return nil
end

function isQueueEnabled()
  return codemasterQueue
end

function startGame()
  -- 1) Determine which team should go first
  -- 2) Randomize keymap layout
  -- 3) Choose the correct double agent card
  -- 4) Deal cards
  -- 5) Start the timer (if enabled)

  -- Determine which team should go first (0 = RED; 1 = BLUE)
  turnTracker = math.random(2) - 1

  -- Shuffle the keymap (R = RED; B = BLUE; W = WHITE; X = BLACK)
  local bank = {"R", "R", "R" ,"R", "R", "R", "R", "R", "B", "B", "B", "B", "B", "B", "B", "B", "W", "W", "W", "W", "W", "W", "W", "X"}
  if turnTracker == 0 then
    -- Add another red
    bank = table.insert(bank, "R")
  else
    -- Add another blue
    bank = table.insert(bank, "B")
  end

  for i = 1, 25, 1 do
    cards[i].color = table.remove(bank, math.random(1, #bank))
  end

  -- Choose the correct double agent card for which team goes first
  local doubleBlue = getObjectFromGUID('1e9282')
  local doubleRed = getObjectFromGUID("3ef1ca")

  if turnTracker == 0 then
    -- Set the correct double card to red
    doubleRed.setLock(false)
    doubleRed.setPosition(agentLocations[doubleRed.guid])
    doubleRed.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(redRot)
    buttonTeams.setPosition(redPos)
    printToAll("Red team's turn.", redColor)
  elseif turnTracker == 1 then
    -- Set the correct double card to blue
    doubleBlue.setLock(false)
    doubleBlue.setPosition(agentLocations[doubleBlue.guid])
    doubleBlue.interactable = true

    -- Change the location of the turn marker
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  end

  dealCards(currentDeck)

  -- Change the gameStarted to 1
  gameStarted = true

  -- Start the timer
  firstTurn = true
  startTime()

  -- Send analytics data for the start of a game
  local payload =
  {
    host = tostring(analytics.host),
    deck = tostring(analytics.deck),
    first = tostring(turnTracker == 0 and "RED" or "BLUE")
  }
  sendAnalytics("Games/Start", payload,
    function(request)
      if request.is_done then
        -- Remember the returned token
        analytics.gameID = request.text

        -- Reset the teams variable and clueID(just to clean things up)
        analytics.teams = {}
        analytics.teams.red = {}
        analytics.teams.blue = {}
        analytics.clueID = nil

        -- Keep track of who is on what team
        local teamTracker = {}

        -- Payload string for players
        local playerPayload = ""

        -- Repopulate the teams
        local i = 1
        for _, player in ipairs(Player.getPlayers()) do
          local color = player.color
          -- Start session for all players currently seated
          if color == "Red" or color == "Orange" or color == "Yellow" or color == "Pink" or color == "Brown" then
            -- Add this player to the red team
            teamTracker[player.steam_id] = "RED"
            playerPayload = playerPayload .. ((i == 1) and player.steam_id or (',' .. player.steam_id))
            i = i + 1
          elseif color == "Blue" or color == "Teal" or color == "Purple" or color == "Green" or color == "White" then
            -- Add this player to the blue team
            teamTracker[player.steam_id] = "BLUE"
            playerPayload = playerPayload .. ((i == 1) and player.steam_id or (',' .. player.steam_id))
            i = i + 1
          end
        end

        local payload =
        {
          gameID = tostring(analytics.gameID),
          players = tostring(playerPayload)
        }
        sendAnalytics("Players/StartSession", payload,
          function(request)
            if request.is_done then
              local response = JSON.decode(request.text)

              for steamID, token in pairs(response) do
                if teamTracker[steamID] == "RED" then
                  -- Add this player to the red team
                  analytics.teams.red[steamID] = token
                elseif teamTracker[steamID] == "BLUE" then
                  -- Add this player to the blue team
                  analytics.teams.blue[steamID] = token
                end
              end
            end
          end)
    end
  end)
end

-- Deals out cards from deck dealer
function dealCards(deck)
      deck.shuffle()
      local draw_parameters =
      {
        rotation = {0, 180, 0},
        flip = true,
        top = true
      }

      for i = 1, 25, 1 do
        local color
        if cards[i].color == "R" then
          -- Card is RED
          color = "#da1918"
        elseif cards[i].color == "B" then
          -- Card is BLUE
          color = "#1f87ff"
        elseif cards[i].color == "W" then
          -- Card is WHITE
          color = "#ffffff"
        elseif cards[i].color == "X" then
          -- Card is BLACK
          color = "#191919"
        end
        draw_parameters.position = {cards[i].position.x, 1.03, cards[i].position.z}
        draw_parameters.callback_function = function(card) attachCardUI(card, i, color) end
        local c = deck.takeObject(draw_parameters)
        c.setLuaScript(string.format([[
        function onLoad()
          local timeSet = %s
          position = {
            %s,
            1.03,
            %s
          }
          rotation = {0, 180, 0}
          if os.time() - timeSet > 5 then
            self.setPosition(position)
            self.setRotation(rotation)
          end
        end

        function onCollisionEnter(collision_info)
          local res, e = pcall(getObject, collision_info)
          if res == false then
            self.setPosition(position)
            self.setRotation(rotation)
          else
            if e != 'Surface' then
              self.setPosition(position)
              self.setRotation(rotation)
            end
          end
        end

        function onCollisionStay(collision_info)
          local res, e = pcall(getObject, collision_info)
          if res == false then
            self.setPosition(position)
            self.setRotation(rotation)
          else
            if e != 'Surface' then
              self.setPosition(position)
              self.setRotation(rotation)
            end
          end
        end

        function onCollisionExit(collision_info)
          local res, e = pcall(getObject, collision_info)
          if res == false then
            self.setPosition(position)
            self.setRotation(rotation)
          else
              if e != 'Surface' then
                self.setPosition(position)
                self.setRotation(rotation)
              end
          end
        end

        function getObject(info)
          return info.collision_object.tag
        end
        ]], os.time(), cards[i].position.x, cards[i].position.z))
    end
end

function attachCardUI(card, i, color)
  cards[i].guid = card.guid

  local bounds = card.getBounds()
  local sizeX = math.floor(bounds.size.x * 75)
  local sizeZ = math.floor(bounds.size.z * 75)
  local size = {X = sizeX, Z = sizeZ}
  cards[i].size = size
  cards[i].value = card.getName()
  card.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
         rectAlignment="MiddleCenter"
         color="%s"
         width="%s"
         height="%s"
         ></Panel>"]], color, sizeZ, sizeX))
  if cards[i].color == "X" then
    card.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
           rectAlignment="MiddleCenter"
           color="%s"
           width="%s"
           height="%s"
           outline="#e7e52c"
           outlineSize="4 -5"
           ></Panel>"]], color, sizeZ, sizeX, sizeZ, sizeX))
  end

  -- Once the last card has loaded in, allow a new game to be started
  if i == 25 then
    newGameStarting = false
  end
end

-- Zone clearing
function clearZone(zoneToClear)
  for _, object in ipairs(zoneToClear.getObjects()) do
    if object.tag =="Card" then
      object.destruct()
    end
  end
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if not gameStarted or agent.tag ~= "Tile" or agentLocations[agent.guid] == nil then
    return
  end

  -- Only RED and BLUE can drop agent cards
  if color ~= "Red" and color ~= "Blue" then
    -- Move the placed card back to its original position
    agent.setPositionSmooth(agentTracker[agent.guid])
    Player[color].broadcast("Only codemasters are able to place agent cards.", redColor)
  end

  -- Find the closest card position to the dropped agent
  local searchThreshold = 1.5
  local closestCard =
  {
    index = nil,
    object = nil,
    distance = nil
  }
  for i = 1, 25, 1 do
    local dX = agent.getPosition().x - cards[i].position.x
    local dZ = agent.getPosition().z - cards[i].position.z

    local d = math.sqrt((dX^2) + (dZ^2))

    if d < searchThreshold then
      if closestCard.object ~= nil then
        -- Compare to the current card
        if d < distance then
          closestCard.index = i
          closestCard.object = getObjectFromGUID(cards[i].guid)
          closestCard.distance = d
        end
      else
        -- No card is currently close, use this one
        closestCard.index = i
        closestCard.object = getObjectFromGUID(cards[i].guid)
        closestCard.distance = d
      end
    end
  end

  if closestCard.index == nil then
    -- No close card found
    return
  end

  -- Set the correct card rotations
  getObjectFromGUID(cards[closestCard.index].guid).setRotationSmooth({0, 180, 0})
  agent.setRotationSmooth({0, 180, 180})

  local agentColor = agentColors[agent.guid]
  local cardColor = cards[closestCard.index].color
  local answerKey =
  {
    ["R"] = "red",
    ["B"] = "blue",
    ["W"] = "white",
    ["X"] = "black"
  }

  if answerKey[cardColor] == agentColor then
    -- Make sure this card hasn't already been covered
    if cards[closestCard.index].covered then
      agent.setPositionSmooth(agentTracker[agent.guid])
      Player[color].broadcast("This code has already been marked correctly.", redColor)
      return
    end

    -- Card is placed correctly
    cards[closestCard.index].covered = true
    guessesLeft = guessesLeft - 1

    local index = closestCard.index
    local card = getObjectFromGUID(cards[index].guid)
    local position = {cards[index].position.x, 1.03, cards[index].position.z}

    -- Lock both cards and set them in place
    card.interactable = false
    agent.interactable = false

    -- Remove the UI from the card
    card.UI.setXml("")

    card.setLock(true)
    agent.setLock(true)

    -- Ensure the tile is on the code
    card.setRotationSmooth({0, 180, 0})
    agent.setRotationSmooth({0, 180, 180})

    card.setPositionSmooth(position)
    agent.setPositionSmooth(position)

    -- Send analytics data for the guess
    local payload =
    {
      clueID = tostring(analytics.clueID),
      players = "",
      guess = tostring(cards[index].value),
      correct = tostring(((turnTracker == 0 and cardColor == "R") or (turnTracker == 1 and cardColor == "B")) and "TRUE" or "FALSE"),
      color = tostring(answerKey[cardColor]:upper())
    }
    local i = 1
    if turnTracker == 0 then
      -- Red's turn
      for steamID,_ in pairs(analytics.teams.red) do
        if Player["Red"] ~= nil and Player["Red"].steam_id ~= steamID then
          payload.players = payload.players .. ((i == 1) and steamID or (',' .. steamID))
          i = i + 1
        end
      end
    elseif turnTracker == 1 then
      -- Blue's turn
      for steamID,_ in pairs(analytics.teams.blue) do
        if Player["Blue"] ~= nil and Player["Blue"].steam_id ~= steamID then
          payload.players = payload.players .. ((i == 1) and steamID or (',' .. steamID))
          i = i + 1
        end
      end
    end
    sendAnalytics("Clues/Guess", payload, function(request) nullFunction() end)

    -- Check to see if either red or blue won
    local redWon = true
    local blueWon = true
    for i = 1, 25, 1 do
      if cards[i].color == "R" and not cards[i].covered then
        redWon = false
      elseif cards[i].color == "B" and not cards[i].covered then
        blueWon = false
      end

      if not redWon and not blueWon then
        -- Skip unnecessary iterations
        break
      end
    end

    if agentColor == "black" or blueWon or redWon then
      -- End game scenario

      -- Analytics data for end of game
      local endPayload =
      {
        gameID = tostring(analytics.gameID)
      }

      if (agentColor == "black" and turnTracker == 0) or blueWon then
        -- Red placed black card, blue wins
        -- or blue placed all of their cards
        broadcastToAll("Blue team wins!", blueColor)
        endPayload.winner = "BLUE"
      elseif (agentColor == "black" and turnTracker == 1) or redWon then
        -- Blue placed black card, red wins
        -- or red placed all of their cards
        broadcastToAll("Red team wins!", redColor)
        endPayload.winner = "RED"
      end

      -- Set the game back to initial state
      gameStarted = false

      -- Set the timer to 0 and disable
      clockTimer.setValue(0)

      -- Move the remaining agents to their codes
      endGame()

      -- Close all player sessions
      local sessionPayload = ""
      local i= 1
      for steamID, token in pairs(analytics.teams.red) do
        sessionPayload = sessionPayload .. ((i == 1) and analytics.teams.red[steamID] or (',' .. analytics.teams.red[steamID]))
        analytics.teams.red[steamID] = nil
        i = i + 1
      end
      for steamID, token in pairs(analytics.teams.blue) do
        sessionPayload = sessionPayload .. ((i == 1) and analytics.teams.blue[steamID] or (',' .. analytics.teams.blue[steamID]))
        analytics.teams.blue[steamID] = nil
        i = i + 1
      end

      -- Send analytics data for the start of a game
      local payload =
      {
        sessions = tostring(sessionPayload)
      }
      -- Send analytics data to end player sessions
      sendAnalytics("Players/EndSession", payload, function(request) nullFunction() end)

      -- Send analytics data for the end of a game
      sendAnalytics("Games/End", endPayload, function(response) nullFunction() end)
    elseif guessesLeft == 0 or agentColor == "white" or (agentColor == "red" and turnTracker == 1) or (agentColor == "blue" and turnTracker == 0) then
      toggleTurns()
    end

  else
    -- Card was placed incorrectly
    agent.setPositionSmooth(agentTracker[agent.guid])
    Player[color].broadcast("An agent has been placed incorrectly. You placed a " .. agentColor .. " agent on a " .. answerKey[cardColor] .. " card.", redColor)
  end
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" then
    for i = 1, 25, 1 do
      if cards[i].guid == object.guid then
        local color
        if cards[i].color == "R" then
          -- Card is RED
          color = "#da1918"
        elseif cards[i].color == "B" then
          -- Card is BLUE
          color = "#1f87ff"
        elseif cards[i].color == "W" then
          -- Card is WHITE
          color = "#ffffff"
        elseif cards[i].color == "X" then
          -- Card is BLACK
          color = "#191919"
        end
        local newObject = object.reload()
        newObject.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
               rectAlignment="MiddleCenter"
               color="%s"
               width="%s"
               height="%s"
               ></Panel>]], color, cards[i].size.Z, cards[i].size.X))
         if cards[i].color == "X" then
           newObject.UI.setXml(string.format([[<Panel visibility="Blue|Red|Black"
                  rectAlignment="MiddleCenter"
                  color="%s"
                  width="%s"
                  height="%s"
                  outline="#e7e52c"
                  outlineSize="4 -5"
                  ></Panel>]], color, cards[i].size.Z, cards[i].size.X))
         end
        break
      end
    end
  elseif object.tag == "Tile" and agentLocations[object.guid] != nil then
    -- Track the original locations of the tiles
    local tileZoneObj = tileZone.getObjects()
    for _, obj in pairs(tileZoneObj) do
      if obj.guid == object.guid then
        agentTracker[object.guid] = object.getPosition()
      end
    end

    -- Prevent picking up of agent tiles from anyone but red or blue
    if color != "Blue" and color != "Red" then
      for guid,_ in pairs(agentLocations) do
        if guid == object.guid then
          object.reload()
        end
      end
    end
  end
end

function endGame()

  local redAgents = {}
  local blueAgents = {}
  local whiteAgents = {}
  local blackAgents = {}

  -- Get the remaining agents
  for guid, agtColor in pairs(agentColors) do
    if getObjectFromGUID(guid).interactable then
      if agtColor == "red" then
        redAgents[#redAgents + 1] = guid
      elseif agtColor == "blue" then
        blueAgents[#blueAgents + 1] = guid
      elseif agtColor == "white" then
        whiteAgents[#whiteAgents + 1] = guid
      elseif agtColor == "black" then
        blackAgents[#blackAgents + 1] = guid
      end
    end
  end

  -- Agent mapping
  local agentMap =
  {
    ["R"] = redAgents,
    ["B"] = blueAgents,
    ["W"] = whiteAgents,
    ["X"] = blackAgents
  }

  -- Assign remaining agents to uncovered clues
  for i = 1, 25, 1 do
    if not cards[i].covered then
      local agent = getObjectFromGUID(table.remove(agentMap[cards[i].color], 1))
      local card = getObjectFromGUID(cards[i].guid)
      local position = {cards[i].position.x, 1.03, cards[i].position.z}

      -- Lock both cards and set them in place
      card.interactable = false
      agent.interactable = false

      card.setLock(true)
      agent.setLock(true)

      -- Ensure the tile is on the code
      card.setRotationSmooth({0, 180, 0})
      agent.setRotationSmooth({0, 180, 180})

      card.setPositionSmooth(position)
      agent.setPositionSmooth(position)
    end
  end
end

function onUpdate()
  -- Check for clock rundown if timer is enabled
  if settings.timer.enabled and newGameStarting == false and gameStarted then
    local timerVal = clockTimer.getValue()
    if timerVal == 0 then
      -- Switch turns
      timerWarning = timerVal
      broadcastToAll("Time's up!", redColor)
      toggleTurns()
    elseif timerVal == 60 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll("1 minute remaining!", redColor)
    elseif timerVal <= 10 and timerWarning != timerVal then
      timerWarning = timerVal
      broadcastToAll(timerVal .. " seconds remaining!", redColor)
    end
  end
end

function round(exact, precision)
   return math.floor(exact*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function toggleTurns()
  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  firstTurn = false

  -- Reset the guesses each team has left
  guessesLeft = -1

  -- Reset the clueID
  analytics.clueID = nil

  if turnTracker == 0 then
    -- Red team's turn ends, switch to blue team
    turnTracker = 1
    buttonRed.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  else
    -- Blue team's turn ends, switch to red team
    turnTracker = 0
    buttonBlu.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  rotateclues()

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    -- Is it the current side's turn?
    if turnTracker == 0 and button.guid == buttonBlu.guid or turnTracker == 1 and button.guid == buttonRed.guid then
      return
    end

    -- Reset the timer warning
    timerWarning = -1

    -- Make sure it isn't the first turn
    firstTurn = false

    -- Reset the guesses each team has left
    guessesLeft = -1

    if turnTracker == 0 then
      -- Red team's turn ends, switch to blue team
      turnTracker = 1
      buttonRed.AssetBundle.playTriggerEffect(0)
      buttonTeams.setRotation(blueRot)
      buttonTeams.setPositionSmooth(bluePos)
      printToAll("Blue team's turn.", blueColor)
    else
      -- Blue team's turn ends, switch to red team
      turnTracker = 0
      buttonBlu.AssetBundle.playTriggerEffect(0)
      buttonTeams.setRotation(redRot)
      buttonTeams.setPositionSmooth(redPos)
      printToAll("Red team's turn.", redColor)
    end

    rotateclues()

    startTime()
  end
end

function ignoreChanges(request)
  table.insert(playersToIgnore, request)
end

function shouldUpdateAnalytics(steamID, color)
  for i, request in ipairs(playersToIgnore) do
    if request.steamID == steamID then
      if request.color == color then
        -- Allow going forward
        table.remove(playersToIgnore, i)
      end
      return false
    end
  end
  -- Player doesn't have a change request - allow by default
  return true
end